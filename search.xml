<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaWeb 开发经验 02]]></title>
    <url>%2F2019%2F04%2F26%2FJavaWeb-%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-02.html</url>
    <content type="text"><![CDATA[java 对象转成 JSON 字符串，出现 $ref原因：List 里含有重复对象使用：DisableCircularReferenceDetect 来禁止循环引用检测 1JSON.toJSONString(list, SerializerFeature.DisableCircularReferenceDetect) 引用是通过$ref来表示的 引用 描述 “$ref”:”..” 上一级 “$ref”:”@” 当前对象，也就是自引用 “$ref”:”$” 根对象 “$ref”:”$.children.0” 基于路径的引用，相当于 root.getChildren().get(0) freemarker 判断对象是否为空12345&lt;#if name??&gt;$&#123;name &#125;&lt;/#if&gt;$&#123;name!'' &#125; 持续更新中…]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>开发经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb 开发经验 01]]></title>
    <url>%2F2019%2F04%2F20%2FJavaWeb-%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-01.html</url>
    <content type="text"><![CDATA[Set 无序不重复可用于比较对象Set 里的元素无放入顺序，元素不可重复。 123456Person person1 = new Person("张三", "男", 20);Person person2 = new Person("张三", "男", 20);Set&lt;Person&gt; hasSet = new HashSet&lt;&gt;();hasSet.add(person1);hasSet.add(person2);System.out.println(hasSet.size()); 字符串转 List&lt;Class&gt;使用的是 JSONArray.parseArray 而不是 JSONArray.parseObject 1List&lt;Mobile&gt; mobiles = (List&lt;Mobile&gt;) JSONArray.parseArray(str, Mobile.class); 关于ajaxupload.js上传图片问题谷歌浏览器慎用有道词典，有道词典会导致body里面多一个元素&lt;audio controls=&quot;controls&quot; style=&quot;display: none;&quot;&gt;&lt;/audio&gt; 大多数的上传插件，为了实现无刷新页面上传，通常都会构建一个虚拟的 iframe 和 form，比如 ajaxupload，它会把 form 的 target 属性指定为 iframe 中的 name 值，目的是指定返回的页面在哪里打开，上传一般都是返回的 json 字符串，所以这时候返回 json 字符串就会被添加到 iframe 的 body 中，再获取 iframe 中 body 的值作为上传文件的返回结果。有道词典会在返回结果中多了一行&lt;audio controls=&quot;controls&quot; style=&quot;display: none;&quot;&gt;&lt;/audio&gt; 可以关掉插件 更换浏览器 Json字符串有转义字符分析：Json 多次转String会产生转义字符如&quot;，\解决方法：封装方法。123456789/** * 处理 json 字符串多出前后双引号和转义符 * @param rspStr * @return */public static String jsonRemoveEscaping(String rspStr) &#123; rspStr = rspStr.replace("\\","").replace("\"&#123;","&#123;").replace("&#125;\"","&#125;"); return rspStr;&#125; 携程 Apollo 配置中心本地启动 注意事项 一般只需要在/opt/settings/server.properties中配置了 env=DEV 就可以直接直接启动（因为 Client 在本地仓库的包上已经有了 meta_server 的信息） IDE 上也可以通过指定 VM 的参数，增加系统属性变量 -D 来实现调试 1-Denv=DEV -Ddev_meta=http://10.20.25.119:18020 判断线程池执行完，再执行下一步 isShutDown当调用shutdown()或shutdownNow()方法后返回为true。 isTerminated当调用shutdown()方法后，并且所有提交的任务完成后返回为true; isTerminated当调用shutdownNow()方法后，成功停止后返回为true; 如果线程池任务正常完成，都为false 123456789101112131415161718192021222324252627List&lt;Integer&gt; typeList = new ArrayList&lt;&gt;(); typeList.add(1); typeList.add(2); typeList.add(3);ExecutorService pool = Executors.newFixedThreadPool(5);try &#123; for (final int type:typeList) &#123; pool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(type); &#125; &#125;); &#125;&#125; finally &#123; if (pool != null) &#123; pool.shutdown(); &#125;&#125;while (!pool.isTerminated()) &#123; // 等待所有子线程结束&#125;System.out.println("end");// 或者// if(pool.isTerminated())&#123;执行完后，要执行的部分（这个会往后面继续走的）&#125; ibatis 查询日期会去掉时分秒 写 sql 的时候可以用 to_char 来转换 自定义转换 自定义转换 通过配置一个 TypeHandler，让 TypeHandler 在转换的时候把java.sql.Date转换成java.sql.Timestamp。 在 sqlMapConfig 中配一下: 1&lt;typeHandler javaType="object" callback="xxx.xxx.OracleObjectTypeHandler"/&gt; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class OracleObjectTypeHandler extends BaseTypeHandler implements TypeHandler &#123; public Object getResult(ResultSet rs, String columnName) throws SQLException &#123; Object object = rs.getObject(columnName); if (rs.wasNull()) &#123; return null; &#125; else &#123; boolean b = object instanceof java.sql.Date; if (b) object = new Date(rs.getTimestamp(columnName).getTime()); return object; &#125; &#125; public Object getResult(ResultSet rs, int columnIndex) throws SQLException &#123; Object object = rs.getObject(columnIndex); if (rs.wasNull()) &#123; return null; &#125; else &#123; boolean b = object instanceof java.sql.Date; if (b) object = new Date(rs.getTimestamp(columnIndex).getTime()); return object; &#125; &#125; public Object getResult(CallableStatement cs, int columnIndex) throws SQLException &#123; Object object = cs.getObject(columnIndex); if (cs.wasNull()) &#123; return null; &#125; else &#123; boolean b = object instanceof java.sql.Date; if (b) object = new Date(cs.getTimestamp(columnIndex).getTime()); return object; &#125; &#125; public Object valueOf(String s) &#123; return s; &#125; public void setParameter(PreparedStatement ps, int i, Object parameter, String jdbcType) throws SQLException &#123; ps.setObject(i, parameter); &#125;&#125; SpringMvc 表单提交时 date 类型form表单中的数据是基本类型的，对时间类型是不支持的 方法一：在对应的 Controller 中新增下面的方法（针对一个类） 12345678910/** * form表单提交 Date类型数据绑定 * @param binder */ @InitBinder public void initBinder(WebDataBinder binder) &#123; SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); dateFormat.setLenient(false); binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true)); &#125; 方法二：在实体类中添加注解 12@DateTimeFormat(pattern="yyyy-MM-dd") private Date birthday; 注：配置&lt;mvc:annotation-driven/&gt;，默认就启用 FormattingConversionServiceFactoryBean 了。 idea 工程上传的图片，页面显示不出来1）idea里面配置static/image/upload文件资源 2）idea中tomcat发布项目的默认路径是项目所在地里的target目录里面，修改工程输出到Tomcat下]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>开发经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式架构 - 协调服务器 Zookeeper]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1%E5%99%A8Zookeeper.html</url>
    <content type="text"><![CDATA[什么是 ZookeeperZookeeper 是一个分布式开源框架，提供了协调分布式应用的基本服务，它向外部应用暴露一组通用服务——分布式同步（Distributed Synchronization）、命名服务（Naming Service）、集群维护（Group Maintenance）等，简化分布式应用协调及其管理的难度，提供高性能的分布式服务。ZooKeeper本身可以以单机模式安装运行，不过它的长处在于通过分布式 ZooKeeper 集群（一个 Leader，多个 Follower），基于一定的策略来保证 ZooKeeper 集群的稳定性和可用性，从而实现分布式应用的可靠性。 Zookeeper 是为别的分布式程序服务的 Zookeeper 本身就是一个分布式程序（只要有半数以上节点存活，zk 就能正常服务） Zookeeper 所提供的服务涵盖：主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统&gt; 一名称服务等 虽然说可以提供各种服务，但是 zookeeper 在底层其实只提供了两个功能：管理(存储，读取)用户程序提交的数据（类似 namenode 中存放的 metadata）； 并为用户程序提供数据节点监听服务； Zookeeper 集群机制Zookeeper 集群的角色： Leader 和 follower 只要集群中有半数以上节点存活，集群就能提供服务 Zookeeper 特性 Zookeeper：一个 leader，多个 follower 组成的集群 全局数据一致：每个 server 保存一份相同的数据副本，client 无论连接到哪个 server，数据都是一致的 分布式读写，更新请求转发，由 leader 实施 更新请求顺序进行，来自同一个 client 的更新请求按其发送顺序依次执行 数据更新原子性，一次数据更新要么成功，要么失败 实时性，在一定时间范围内，client 能读到最新数据 Zookeeper 数据结构Zookeeper 应用场景数据发布与订阅（配置中心）发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。 负载均衡这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。 命名服务(Naming Service) 分布式通知/协调 集群管理与Master选举 分布式锁 分布式事务 持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>架构</tag>
        <tag>协调服务器</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式架构 - 微服务框架Dubbo]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6Dubbo.html</url>
    <content type="text"><![CDATA[Dubbo 的背景随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。 单一应用架构：当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 此时，用于简化增删改查工作量的数据访问框架（ORM）是关键。 垂直应用架构：当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 此时，用于加速前端页面开发的Web框架（MVC）是关键。 分布式服务架构：当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 此时，用于提高业务复用及整合的分布式服务框架（RPC）是关键。 流动计算架构：当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键。 什么是 DubboDubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，SOA 服务治理方案。 简单的说，dubbo 就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有 dubbo 这样的分布式服务框架的需求。 并且本质上是个服务调用，说白了就是个远程服务调用的分布式框架（告别 Web Service 模式中的 wsdl,以服务者与消费者的方式在 dubbo 上注册）。 其核心部分包含: 1.远程通讯: 提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。 2.集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 3.自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 Dubbo能做什么具体能做什么： 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 总结：Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 Spring 的 Schema 扩展进行加载。 Dubbo 架构Dubbo 已进入 Apache 孵化器。Apache Dubbo官网地址 节点角色说明： Provider: 暴露服务的服务提供方。 Consumer: 调用远程服务的服务消费方。 Registry: 服务注册与发现的注册中心。 Monitor: 统计服务的调用次调和调用时间的监控中心。 Container: 服务运行容器。 调用关系说明： 0.服务容器负责启动，加载，运行服务提供者。 1.服务提供者在启动时，向注册中心注册自己提供的服务。 2.服务消费者在启动时，向注册中心订阅自己所需的服务。 3.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 更多详细教程可参考官方文档 持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>架构</tag>
        <tag>微服务</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构 - Spring Cloud]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-Spring-Cloud.html</url>
    <content type="text"><![CDATA[什么是微服务Spring Cloud 是 Spring 旗下的项目之一，Spring Cloud 官网地址：http://projects.spring.io/spring-cloud/ Spring 最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。Spring Cloud 也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： Spring Cloud Netflix Eureka：注册中心 Zuul：服务网关 Ribbon：负载均衡 Feign：服务调用 Hystix：熔断器 Spring Cloud Config：由 git 存储库支持的集中式外部配置管理。 Spring Cloud Bus：用于将服务和服务实例与分布式消息相连接的事件总线，在集群中传播状态变化（例如配置更改事件）。持续更新中…]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构 - Spring Boot]]></title>
    <url>%2F2018%2F06%2F14%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-Spring-Boot.html</url>
    <content type="text"><![CDATA[什么是SpringBootSpringBoot 是 Spring 项目中的一个子工程，与我们所熟知的 Spring-framework 同属于 spring 的产品。 我们可以看到下面的一段介绍： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把 Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的 spring 项目，并且尽可能的减少一切 xml 配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 为什么要学习SpringBootjava 一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能 Python 程序员已经把功能写好了，究其原因注意是两点： 复杂的配置 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 我们可以使用 SpringBoot 创建 java 应用，并使用java –jar启动它，就能得到一个生产级别的 web 工程。 SpringBoot的优点Spring Boot 主要目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验。 开箱即用（启动器 starter-其实就是 SpringBoot 提供的一个 jar 包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等。 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到Spring boot 官网查看。 快速入门创建工程创建 maven 名为 springboot-demo 的 Spring Boot 工程。 添加依赖123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.github.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写启动类123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 编写 controller12345678@RestControllerpublic class HelloController &#123; @GetMapping("hello") public String hello()&#123; return "hello, spring boot!"; &#125;&#125; 更多技能 Spring boot 整合 mybatis Spring boot 整合 jpa Spring boot 整合 redis Spring boot 整合 MQ Spring boot 整合 … 更多细节，大家可以到Spring boot 官网查看。]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统 - 内存数据库Redis]]></title>
    <url>%2F2018%2F05%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93Redis.html</url>
    <content type="text"><![CDATA[什么是 NoSqlNoSQL，即 Not-Only SQL，泛指非关系型的数据库。它是为了解决高并发、高可用、高可扩展、大数据存储问题而产生的数据库解决方案。NoSQL 可以作为关系型数据库的良好补充，但是不能替代关系型数据库。 NoSql 数据库分类键值(Key-Value)存储数据库相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 列存储数据库相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库相关产品：CouchDB、MongoDB典型应用：Web 应用（与 Key-Value 类似，Value 是结构化的）数据模型： 一系列键值对优势：数据结构要求不严格劣势：查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 Redis 是什么Redis 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止 Redis 支持的键值数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型 Redis 的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等）。 分布式集群架构中的 session 分离。 聊天室的在线好友列表。 任务队列。（秒杀、抢购、12306 等等） 应用排行榜。 网站访问统计。 数据过期处理（可以精确到毫秒） 持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>系统</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式架构 - Nginx]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-Nginx.html</url>
    <content type="text"><![CDATA[什么是 NginxNginx 是俄罗斯人编写的一款高性能的 HTTP 和反向代理服务器。 在高连接并发的情况下，它能够支持高达 50000 个并发连接数的响应，但是内存、CPU 等系统资源消耗却很低，运行很稳定。 Nginx 的优势选择 Nginx 的理由也很简单： 第一，它可以支持5W高并发连接； 第二，内存消耗少； 第三，成本低，如果采用 F5、NetScaler 等硬件负载均衡设备的话，需要大几十万。而 Nginx 是开源的，可以免费使用并且能用于商业用途。 分布式架构中的作用最常用的有三项： 路由功能（与微服务对应）：域名/路径，进行路由选择后台服务器； 负载功能（与高并发高可用对应）：对后台服务器集群进行负载； 静态服务器（比 Tomcat 性能高很多）：在 mvvm 模式中，充当文件读取职责。 总结：实际使用中，这三项功用，会混合使用。比如先分离动静，再路由服务，再负载机器。 代理正向代理：客户端自己请求出现困难。客户请了一个代理，来代自己做事，就叫代理。比如代理律师，代购，政府机关办事的代理人等等。反向代理：服务端推出的一个代理招牌。 Nginx 安装源码编译方式一般系统中已经装了了 make 和 g++，无须再装。1234# 安装 makeyum -y install autoconf automake make# 安装 g++yum -y install gcc gcc-c++ 安装nginx依赖的库123456# 安装 pcre yum -y install pcre pcre-devel# 安装 zlib yum -y install zlib zlib-devel# 安装 openssl yum install -y openssl openssl-devel Nginx 官方下载地址 安装 Nginx 123456789# 下载 Nginxwget http://nginx.org/download/nginx-1.16.0.tar.gz# 解压 Nginxtar -zxvf nginx-1.16.0.tar.gzcd nginx-1.16.0# 安装 HTTPS 模块./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module# 安装make &amp;&amp; make install --prefix 指定安装目录--with-http_ssl_module 安装 HTTPS 模块make 编译make install 安装 yum 方式Linux 系统下：123# yum扩展源yum install epel-release -yyum install nginx -y 目录结构 Conf：配置文件 Html：网页文件 Logs：日志文件 Sbin：二进制程序 启停命令./nginx -c nginx.conf的文件。如果不指定，默认为 NGINX_HOME/conf/nginx.conf./nginx -s stop 停止./nginx -s quit 退出./nginx -s reload 重新加载 nginx.conf 发送信号的方式kill -QUIT 进程号 安全停止kill -TERM 进程号 立即停止 配置文件Nginx 全局属性的配置12345678910111213#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125; user：主模块命令， 指定Nginx的worker进程运行用户以及用户组，默认由 nobody 账号运行。worker_processes: 指定 Nginx 要开启的进程数。error_log：用来定义全局错设日志文件的路径和日志名称。日志输出级别有 debug，info，notice，warn，error，crit 可供选择，其中 debug 输出日志最为详细，而 crit（严重）输出日志最少。默认是 error。 pid: 用来指定进程 id 的存储文件位置。event：设定 nginx 的工作模式及连接数上限，其中参数 use 用来指定 nginx 的工作模式（这里是 epoll，epoll 是多路复用 IO(I/O Multiplexing)中的一种方式）,nginx 支持的工作模式有 select ,poll,kqueue,epoll,rtsig,/dev/poll。其中 select 和 poll 都是标准的工作模式，kqueue 和 epoll 是高效的工作模式，对于 linux 系统，epoll 是首选。 worker_connection：是设置 nginx 每个进程最大的连接数，默认是1024，所以nginx最大的连接数 max_client=worker_processes * worker_connections。进程最大连接数受到系统最大打开文件数的限制，需要设置 ulimit。 http 服务器相关属性的配置1234567891011121314151617http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; include：主模块命令，对配置文件所包含文件的设定，减少主配置文件的复杂度，相当于把部分设置放在别的地方，然后在包含进来，保持主配置文件的简洁。default_type：默认文件类型，当文件类型未定义时候就使用这类设置的。log_format：设定日志格式。sendfile：开启高效文件传输模式（zero copy 方式），避免内核缓冲区数据和用户缓冲区数据之间的拷贝。tcp_nopush：开启 TCP_NOPUSH 套接字（sendfile 开启时有用）keepalive_timeout：客户端连接超时时间gzip：设置是否开启 gzip 模块 server 段虚拟主机的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125;&#125; listen：虚拟主机的服务端口server_name：用来指定ip或者域名，多个域名用逗号分开charset：设置字符编码location /：默认请求 root：虚拟主机的网页根目录 index：默认访问首页文件error_page：定义错误提示页面location ~ .php$：PHP 脚本请求全部转发到 FastCGI 处理.，使用FastCGI默认配置。location ~ /.ht：禁止访问 .htxxx 文件 Nginx 日志描述通过访问日志，你可以得到用户地域来源、跳转来源、使用终端、某个URL访问量等相关信息；通过错误日志，你可以得到系统某个服务或server的性能瓶颈等。 因此，将日志好好利用，你可以得到很多有价值的信息。 日志格式打开nginx.conf配置文件：vi /usr/local/nginx/conf/nginx.conf日志部分内容：#access_log logs/access.log main; 日志生成的到 Nginx 根目录 logs/access.log 文件，默认使用 main 日志格式，也可以自定义格式。 参数明细表 参数 说明 $remote_addr 客户端的ip地址(代理服务器，显示代理服务ip) $remote_user 用于记录远程客户端的用户名称（一般为“-”） $time_local 用于记录访问时间和时区 $request 用于记录请求的url以及请求方法 $status 响应状态码，例如：200成功、404页面找不到等。 $body_bytes_sent 给客户端发送的文件主体内容字节数 $http_user_agent 用户所使用的代理（一般为浏览器） $http_x_forwarded_for 可以记录客户端IP，通过代理服务器来记录客户端的ip地址 $http_referer 可以记录用户是从哪个链接访问过来的 查看日志命令 tail -f /usr/local/nginx/logs/access.log持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>架构</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
</search>
