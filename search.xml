<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringMVC 返回 json 字符串中文乱码]]></title>
    <url>%2F2018%2F04%2F19%2FSpringMVC-%E8%BF%94%E5%9B%9E-json-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81.html</url>
    <content type="text"><![CDATA[原因 最近在写一些小的Demo案例，但是被AJAX的 json 返回乱码折磨了好久。最后通过研究StringHttpMessageConverter源代码发现，开发者很坑的使用了”ISO-8859-1”作为默认编码。经过代码测试，下面给出四种方法解决SpringMVC 返回 json 字符串中文乱码。（本文spring版本4.3.11.RELEASE） 12345public class StringHttpMessageConverter extends AbstractHttpMessageConverter&lt;String&gt; &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("ISO-8859-1"); private volatile List&lt;Charset&gt; availableCharsets; private boolean writeAcceptCharset; // 后面省略 方法一：自己编写一个工具类学过servlet我们可以知道，可以通过HttpServletResponse设置返回编码。 工具类12345678910public class ResponseTool &#123; public static void write(HttpServletResponse response,Object o)throws Exception&#123; response.setContentType("text/html;charset=utf-8"); PrintWriter out=response.getWriter(); out.println(o.toString()); out.flush(); out.close(); &#125;&#125; 测试方法1234567@RequestMapping(value = "/toolToJson")public void toolToJson(HttpServletResponse response) throws Exception &#123; Map map = new HashMap(); map.put("code", "200"); map.put("msg", "这是一句话，测试返回json是否乱码。"); ResponseTool.write(response,new Gson().toJson(map));&#125; 方法二：使用produces属性在RequestMapping使用（produces = “text/html; charset=utf-8”）produces 作用根据请求头中的Accept进行匹配，如请求头“Accept:text/html”时即可匹配。 如果类型是：application/json ，设置为：produces = “application/json; charset=utf-8”测试方法12345678@RequestMapping(value = "/producesToJson", method = RequestMethod.GET, produces="text/html;charset=UTF-8")@ResponseBodypublic String producesToJson() &#123; Map map = new HashMap(); map.put("code", "200"); map.put("msg", "这是一句话，测试返回json是否乱码。"); return new Gson().toJson(map);&#125; 方法三：通过配置spring-mvc.xml在spring-mvc.xml添加配置1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 测试方法 12345678@RequestMapping(value = "/json")@ResponseBodypublic String json() &#123; Map map = new HashMap(); map.put("code", "200"); map.put("msg", "这是一句话，测试返回json是否乱码。"); return new Gson().toJson(map);&#125; 方法四：完成自己的AbstractHttpMessageConverter分析源码可以看出StringHttpMessageConverter继承与AbstractHttpMessageConverter，分析该抽象类得，相关的操作字符编码的方法可以重写，于是我们可以自定义一个类继承StringHttpMessageConverter，然后重写相关的方法。这里我们只需要把ISO-8859-1改成UTF-8，并修改构造方法。 UTF8StringHttpMessageConverter 类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.javazhan.controller;import org.springframework.http.HttpInputMessage;import org.springframework.http.HttpOutputMessage;import org.springframework.http.MediaType;import org.springframework.http.converter.AbstractHttpMessageConverter;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.http.converter.HttpMessageNotWritableException;import org.springframework.util.StreamUtils;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.List;/** * @Author: yandq * @Description: * @Date: Create in 11:50 2018/4/3 * @Modified By: */public class UTF8StringHttpMessageConverter extends AbstractHttpMessageConverter&lt;String&gt; &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); private volatile List&lt;Charset&gt; availableCharsets; private boolean writeAcceptCharset; public UTF8StringHttpMessageConverter() &#123; this(DEFAULT_CHARSET); &#125; public UTF8StringHttpMessageConverter(Charset defaultCharset) &#123; super(defaultCharset, new MediaType[]&#123;MediaType.TEXT_PLAIN, MediaType.ALL&#125;); this.writeAcceptCharset = true; &#125; public void setWriteAcceptCharset(boolean writeAcceptCharset) &#123; this.writeAcceptCharset = writeAcceptCharset; &#125; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return String.class == clazz; &#125; @Override protected String readInternal(Class&lt;? extends String&gt; clazz, HttpInputMessage inputMessage) throws IOException &#123; Charset charset = this.getContentTypeCharset(inputMessage.getHeaders().getContentType()); return StreamUtils.copyToString(inputMessage.getBody(), charset); &#125; @Override protected Long getContentLength(String str, MediaType contentType) &#123; Charset charset = this.getContentTypeCharset(contentType); try &#123; return (long)str.getBytes(charset.name()).length; &#125; catch (UnsupportedEncodingException var5) &#123; throw new IllegalStateException(var5); &#125; &#125; @Override protected void writeInternal(String str, HttpOutputMessage outputMessage) throws IOException &#123; if (this.writeAcceptCharset) &#123; outputMessage.getHeaders().setAcceptCharset(this.getAcceptedCharsets()); &#125; Charset charset = this.getContentTypeCharset(outputMessage.getHeaders().getContentType()); StreamUtils.copy(str, charset, outputMessage.getBody()); &#125; protected List&lt;Charset&gt; getAcceptedCharsets() &#123; if (this.availableCharsets == null) &#123; this.availableCharsets = new ArrayList(Charset.availableCharsets().values()); &#125; return this.availableCharsets; &#125; private Charset getContentTypeCharset(MediaType contentType) &#123; return contentType != null &amp;&amp; contentType.getCharset() != null ? contentType.getCharset() : this.getDefaultCharset(); &#125;&#125; 定义好上面的类后，只需要将该类注册到Spring的annotaion 处理序列中即可，当加上@ResponseBody时，Spring将会调用上面自定义类中复写的方法，从而返回UTF-8的编码： 12345&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;bean class="com.javazhan.controller.UTF8StringHttpMessageConverter"/&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 测试方法 12345678@RequestMapping(value = "/json")@ResponseBodypublic String json() &#123; Map map = new HashMap(); map.put("code", "200"); map.put("msg", "这是一句话，测试返回json是否乱码。"); return new Gson().toJson(map);&#125;]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 全局搜索快捷键 Ctrl +Shift+F，不起作用啦，啥情况]]></title>
    <url>%2F2018%2F04%2F17%2FIDEA-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%E5%BF%AB%E6%8D%B7%E9%94%AE-Ctrl-Shift-F%EF%BC%8C%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E5%95%A6%EF%BC%8C%E5%95%A5%E6%83%85%E5%86%B5.html</url>
    <content type="text"><![CDATA[问题描述IDEA 工具很强大，其中有个全局搜索快捷键：Ctrl +Shift+F也是在开发中经常用到的，但是不知道为什么按了就是不起作用，原来是和输入法的简繁体切换冲突了 给出一下三种解决方法方案一 如你不想要输入法的简繁体切换快捷键，win10 最新版2017年7月可以直接取消简繁体切换快捷键（搜狗输入法可以在设置里改）如下 打开win设置（右键任务栏左下角微软的LOGO，单击设置） 点击时间和语言，区域和语言，中文，选项 微软拼音，选项 点击按键 关掉简繁体输入切换 在我们的idea中试一下，哈哈终于可以了。。。（赶紧撸代码吧） 方案二，若不是最新版或者其他系统，可以在控制面板里改。如下我的是win10最新版（右键任务栏左下角微软的LOGO，单击控制面板已取消，不知道为什么，哈哈哈） 我们可以这样打开运行框（windows键+R）,输入Control 按这个顺序进去控制面板\时钟、语言和区域\语言\高级设置 更改语言栏热键 在输入语言之间，更改按键顺序，Ctrl+Shift，应用，确定 在我们的idea中试一下，哈哈终于可以了。。。（赶紧撸代码吧） 如你的没有好使，不要急于给我评论，问我这个问题，看看你的输入法是不是中文，切换成英文，再次按Ctrl +Shift+F，是不是出来了 方案三 若你要保留输入法的简繁体切换快捷键，可以在idea的全局搜索快捷键，新增一个快捷键，如：Ctrl +Shift+o。Ctrl +Alt+S 打开配置选择 Keymap，执行以下三步找到全局搜索快捷键第一步：点击shortcut查询第二步：勾上 second stroke第三步：在输入，按下Ctrl +Shift+F 在Find in Path右键，Add Keyboard Shortcut 直接按下你想用的快捷键（不要和其他的冲突了），如：Ctrl +Shift+o应用保存，就好了。 在我们的idea中试一下，哈哈终于可以了。。。（赶紧撸代码吧）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中使用Swagger2构建RESTful APIS]]></title>
    <url>%2F2018%2F04%2F16%2FSpring-Boot%E4%B8%AD%E4%BD%BF%E7%94%A8Swagger2%E6%9E%84%E5%BB%BARESTful-APIS.html</url>
    <content type="text"><![CDATA[Swagger2简介本次教程是Spring Boot中使用Swagger2构建RESTful APISSwagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。（如图） Swagger除了查看接口功能外，还提供了调试测试功能。（如图）新增博客 查看所有博客 修改博客 查看单个博客 删除博客 SpringBoot整合Swagger2配置pom.xml,引入Swagger2架包 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 在RunApplication.java同级下创建Swagger2.java 1234567891011121314151617181920212223242526272829303132333435363738package com.javazhan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.*;import springfox.documentation.service.*;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Created by yando on 2017/11/10. */@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .build() .apiInfo(apiInfo()); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("Spring Boot中使用Swagger2构建RESTful APIS") .description("HTTP对外开放接口") .version("1.0.0") .termsOfServiceUrl("http://blog.csdn.net/wenteryan") .license("Spring Boot 入门+实战（提供源码哟）") .licenseUrl("http://blog.csdn.net/column/details/15021.html") .build(); &#125;&#125; 创建实体类 Blog.java（略） 创建ABlogController.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.javazhan.controller.admin;import com.javazhan.domain.Blog;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.*;import java.util.*;/** * Created by yando on 2017/11/13. */@RestController@RequestMapping(value = "/admin/blog")public class ABlogController &#123; static Map&lt;Long, Blog&gt; blogs = Collections.synchronizedMap(new HashMap&lt;Long, Blog&gt;()) ; @ApiOperation(value = "后台管理查询所有博客") @RequestMapping(value = "", method = RequestMethod.GET) public List&lt;Blog&gt; getBlogList() &#123; List&lt;Blog&gt; list = new ArrayList&lt;Blog&gt;(blogs.values()) ; return list ; &#125; @ApiOperation(value = "新增博客", notes = "根据博客对象") @ApiImplicitParam(name = "blog", value = "博客信息实体blog", required = true, dataType = "Blog") @RequestMapping(value = "/add", method = RequestMethod.POST) public Map addBlog(@RequestBody Blog blog) &#123; blogs.put(blog.getId(), blog) ; Map map = new HashMap() ; map.put("message", "新增成功") ; map.put("code", "0000") ; return map ; &#125; @ApiOperation(value = "获取博客信息", notes = "根据ID获取博客对象") @ApiImplicitParam(name = "id", value = "博客ID", required = true, paramType="path", dataType = "Long") @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.GET) public Blog getBlogById(@PathVariable Long id) &#123; Blog blog = new Blog() ; blog = blogs.get(id) ; return blog ; &#125; @ApiOperation(value = "修改博客信息", notes = "根据传过来的博客对象修改博客信息") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "id", value = "博客ID", required = true, paramType="path", dataType = "Long"), @ApiImplicitParam(name = "blog", value = "博客信息实体blog", required = true, dataType = "Blog") &#125;) @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.PUT) public Map updateBlog(@PathVariable Long id, @RequestBody Blog blog) &#123; Blog b = blogs.get(blog.getId()) ; b.setId(blog.getId()) ; b.setName(blog.getName()) ; blogs.put(b.getId(), b) ; Map map = new HashMap() ; map.put("message", "修改成功") ; map.put("code", "0000") ; return map ; &#125; @ApiOperation(value = "删除博客信息", notes = "根据ID删除博客对象") @ApiImplicitParam(name = "id", value = "博客ID", required = true, paramType="path", dataType = "Long") @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.DELETE) public Map deleteBlog(@PathVariable Long id) &#123; blogs.remove(id) ; Map map = new HashMap() ; map.put("message", "删除成功") ; map.put("code", "0000") ; return map ; &#125;&#125; 运行RunApplication.java访问地址：http://localhost:8080/swagger-ui.html 更多教程请参考官方文档 源码下载Spring Boot中使用Swagger2构建RESTful APIS（含源码）]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot进阶之统一异常处理]]></title>
    <url>%2F2018%2F04%2F13%2FSpringBoot%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[浅谈异常处理在J2EE项目的开发中，不管是对底层的数据库操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。每个过程都单独处理异常，系统的代码耦合度高，工作量大且不好统一，维护的工作量也很大。 所以我们会进行统一异常处理，进而去避免这些问题。 默认异常处理Spring Boot提供了一个默认的映射：/error，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。 启动该应用，访问一个不存在的URL。 统一异常处理，场景1 返回HTML页面编写全局异常处理类 GlobalExceptionHandler.java 12345678910111213141516// 通过使用@ControllerAdvice定义统一的异常处理类，而不是在每个Controller中逐个定义。@ControllerAdvicepublic class GlobalExceptionHandler &#123; public static final String DEFAULT_ERROR_VIEW = "error"; // @ExceptionHandler用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到error.html中 @ExceptionHandler(value = Exception.class) public ModelAndView defaultErrorHandler(HttpServletRequest request, Exception e) throws Exception &#123; ModelAndView mav = new ModelAndView() ; mav.addObject("errorname", "统一异常处理页面") ; mav.addObject("exception", e) ; mav.addObject("url", request.getRequestURL()) ; mav.setViewName(DEFAULT_ERROR_VIEW) ; return mav ; &#125;&#125; 编写异常类 ExceptionController.java 12345678@Controllerpublic class ExceptionController &#123; @RequestMapping("/nException") public String nException() throws Exception &#123; throw new Exception("这里有个错误异常") ; &#125;&#125; 编写error.html页面 123456789&lt;div class="container"&gt; &lt;br&gt;&lt;/br&gt; &lt;div class="alert alert-warning alert-dismissible" role="alert"&gt; &lt;button type="button" class="close" data-dismiss="alert" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h2 th:text="$&#123;errorname &#125;"&gt;&lt;/h2&gt; &lt;p th:text="$&#123;exception.message &#125;"&gt;&lt;/p&gt; &lt;p th:text="$&#123;url &#125;"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 启动应用，访问：http://localhost:8080/nException 统一异常处理，场景2 返回JSON页面编写ErrorInfo.java实体类 1234567891011121314151617181920212223242526272829303132333435package com.javazhan.domain;public class ErrorInfo&lt;T&gt; &#123; public static final Integer OK = 0000 ; public static final Integer ERROR = 9999 ; private Integer code ; private String message ; private String url ; private T data ; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; &#125; 在全局异常处理类 GlobalExceptionHandler.java编写jsonErrorHandler方法 12345678910@ExceptionHandler(value = MyException.class)@ResponseBodypublic ErrorInfo&lt;String&gt; jsonErrorHandler(HttpServletRequest request, MyException e) throws Exception &#123; ErrorInfo&lt;String&gt; r = new ErrorInfo&lt;&gt;() ; r.setMessage(e.getMessage()) ; r.setCode(ErrorInfo.ERROR) ; r.setData("Some Data") ; r.setUrl(request.getRequestURL().toString()) ; return r ;&#125; 在ExceptionController.java新增jsonException方法1234@RequestMapping("/jsonException")public String jsonException() throws MyException &#123; throw new MyException("这里有个错误异常");&#125; 启动应用，访问：http://localhost:8080/jsonException 源码下载SpringBoot进阶之统一异常处理（含源码）]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot自定义favicon.ico]]></title>
    <url>%2F2018%2F04%2F12%2FSpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89favicon-ico.html</url>
    <content type="text"><![CDATA[默认的FaviconSpring Boot提供了一个默认的Favicon，每次访问应用的时候都能看到。 关闭Favicon我们可以在application.properties中设置关闭Favicon，默认为开启。 1spring.mvc.favicon.enable=false 或在application.yml中设置关闭Favicon 1234spring: mvc: favicon: enabled: false 设置自己的Favicon若需要设置自己的Favicon，则只需将自己的favicon.ico文件放置在类路径根目录、类路径META-INF/resources/下、类路径resources/下、类路径static/下或类路径public/下。 这里将favicon.ico放置在src/main/resources/static下。 源码分析application.properties1spring.mvc.favicon.enabled=false IndexController .java123456789@Controllerpublic class IndexController &#123; @RequestMapping(value = "/index") public String index(Model model) &#123; model.addAttribute("name","SpringBootFavicon"); return "index"; &#125;&#125; IndexRestController .java12345678@RestControllerpublic class IndexRestController &#123; @RequestMapping(value = "/indexRest") public String index() &#123; return "indexRest"; &#125;&#125; RunApplication .java1234567@SpringBootApplicationpublic class RunApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RunApplication.class, args) ; &#125;&#125; 运行RunApplication,java 效果图访问Rest请求 访问页面 访问错误请求 源码下载SpringBoot自定义favicon.ico(含源码) SpringBoot 入门+实战系列源码)]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot进阶之访问数据库]]></title>
    <url>%2F2018%2F04%2F11%2FSpringBoot%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
    <content type="text"><![CDATA[本文介绍在Spring Boot基础下配置数据源和通过JdbcTemplate编写数据访问的示例。 简单介绍一下@Controller：修饰class，用来创建处理http请求的对象@RestController：Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。@RequestMapping：配置url映射 数据源配置 首先，为了连接数据库需要引入jdbc支持，在pom.xml中引入如下配置：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 以MySQL数据库为例，先引入MySQL连接的依赖包，在pom.xml中加入： 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt;&lt;/dependency&gt; 配置数据源信息在application.yml配置数据源信息123456spring: datasource: url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8 username: root password: root driver-class-name: com.mysql.jdbc.Driver 使用JdbcTemplate操作数据库编写实体类Student.java 12345678910111213141516171819202122232425262728293031323334package com.javazhan.domain;public class Student &#123; private int id ; private String name ; private int age ; private String address ; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; 编写StudentService.java 12345678910111213141516171819202122232425262728293031323334353637package com.javazhan.service;import java.util.List;import com.javazhan.domain.Student;public interface StudentService &#123; /** * 新增一个学生 * @param student */ void create(Student student) ; /** * 根据id删除一个学生 * @param id */ void deleteById(int id) ; /** * 查出所有学生 * @return */ List&lt;Student&gt; getAllStudent() ; /** * 根据id查出学生 * @return */ Student getStudentById(int id) ; /** * 根据Id更新一个学生 */ void updateStudentById(Student student) ;&#125; 编写实现类StudentServiceImpl.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.javazhan.service.impl;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.ResultSetExtractor;import org.springframework.jdbc.core.RowMapper;import org.springframework.stereotype.Service;import com.javazhan.domain.Student;import com.javazhan.service.StudentService;@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private JdbcTemplate jdbcTemplate ; @Override public void create(Student student) &#123; // TODO Auto-generated method stub jdbcTemplate.update("insert into student(name, age, address) value(?,?,?)", student.getName(), student.getAge(), student.getAddress()) ; &#125; @Override public void deleteById(int id) &#123; // TODO Auto-generated method stub jdbcTemplate.update("delete from student where id = ?", id) ; &#125; @Override public List&lt;Student&gt; getAllStudent() &#123; // TODO Auto-generated method stub return jdbcTemplate.query("select * from student", new RowMapper() &#123; @Override public Object mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Student student = new Student(); student.setId(rs.getInt("id")); student.setName(rs.getString("name")); student.setAge(rs.getInt("age")); student.setAddress(rs.getString("address")); return student; &#125; &#125;) ; &#125; @Override public Student getStudentById(int id) &#123; // TODO Auto-generated method stub return (Student) jdbcTemplate.query("select * from student where id=?", new ResultSetExtractor() &#123; @Override public Student extractData(ResultSet rs) throws SQLException &#123; while (rs.next()) &#123; Student student = new Student(); student.setId(rs.getInt("id")); student.setName(rs.getString("name")); student.setAge(rs.getInt("age")); student.setAddress(rs.getString("address")); return student ; &#125; return null ; &#125; &#125;, id); &#125; @Override public void updateStudentById(Student student) &#123; // TODO Auto-generated method stub jdbcTemplate.update("update student set name=?, age=?, address=? where id =?", student.getName(), student.getAge(), student.getAddress(),student.getId()) ; &#125; &#125; 我们尝试使用Spring MVC来实现一组对Student对象操作的RESTful API，配合注释详细说明在Spring MVC中如何映射HTTP请求、如何传参、如何编写单元测试。| 请求类型 | URL | 功能说明 || ————- |:————-| —–|| GET | /student | 查询所有学生 || POST | /student | 新增一个学生 || GET | /student/id | 根据id查询一个学生 || PUT | /student/id | 根据id更新一个学生 || DELETE | /student/id | 根据id删除一个学生 | 编写StudentRestController .java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.javazhan.web.rest;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import com.javazhan.domain.Student;import com.javazhan.service.StudentService;@RestController@RequestMapping(value="student")public class StudentRestController &#123; @Autowired private StudentService stuService ; /** * 查出所有学生 * @return */ @RequestMapping(value="/", method=RequestMethod.GET) public List&lt;Student&gt; getAllStudent() &#123; return stuService.getAllStudent() ; &#125; /** * 根据id查出学生 * @return */ @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.GET) public Student getStudentById(@PathVariable Integer id) &#123; return stuService.getStudentById(id) ; &#125; /** * 根据id删除学生 * @return */ @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.DELETE) public String deleteById(@PathVariable Integer id) &#123; stuService.deleteById(id) ; return "success" ; &#125; /** * 新增一个学生 * @return */ @RequestMapping(value="/", method=RequestMethod.POST) public String create(@ModelAttribute Student student) &#123; stuService.create(student) ; return "success" ; &#125; /** * 根据Id更新一个学生 * @return */ @RequestMapping(value="/", method=RequestMethod.PUT) public String updateStudentById(@ModelAttribute Student student) &#123; stuService.updateStudentById(student) ; return "success" ; &#125;&#125; 编写测试RestTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.java.test;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.RequestBuilder;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;import com.javazhan.RunApplication;@RunWith(SpringRunner.class)@SpringBootTest(classes=RunApplication.class)public class RestTest &#123; @Autowired private WebApplicationContext context; // mock api 模拟http请求 private MockMvc mvc; @Before public void setUp() throws Exception &#123; //集成Web环境测试（此种方式并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器） mvc = MockMvcBuilders.webAppContextSetup(context).build(); &#125; @Test public void testUserController() throws Exception &#123; RequestBuilder request = null ; MvcResult mvcResult = null ; int status = 500 ; // 新增学生 request = post("/student/").param("name", "李四") .param("age", "20") .param("address", "哈尔滨") ; mvcResult = mvc.perform(request).andReturn() ; status = mvcResult.getResponse().getStatus() ; if(status==200) &#123; String content = mvcResult.getResponse().getContentAsString() ; System.out.println("新增学生："+content) ; &#125; // 查出所有学生 request = get("/student/") ; mvcResult = mvc.perform(request).andReturn() ; status = mvcResult.getResponse().getStatus() ; if(status==200) &#123; String content = mvcResult.getResponse().getContentAsString() ; System.out.println("查出所有学生："+content); &#125; // 根据Id查询学生 request = get("/student/1") ; mvcResult = mvc.perform(request).andReturn() ; status = mvcResult.getResponse().getStatus() ; if(status==200) &#123; String content = mvcResult.getResponse().getContentAsString() ; System.out.println("根据Id查询学生："+content) ; &#125; // 根据Id更新一个学生 request = put("/student/").param("id", "5") .param("name", "李四5") .param("age", "25") .param("address", "哈尔滨5") ; mvcResult = mvc.perform(request).andReturn() ; status = mvcResult.getResponse().getStatus() ; if(status==200) &#123; String content = mvcResult.getResponse().getContentAsString() ; System.out.println("根据Id更新一个学生："+content) ; &#125; // 根据id删除一个学生 request = delete("/student/6") ; mvcResult = mvc.perform(request).andReturn() ; status = mvcResult.getResponse().getStatus() ; if(status==200) &#123; String content = mvcResult.getResponse().getContentAsString() ; System.out.println("根据id删除一个学生："+content) ; &#125; &#125;&#125; 编写RunApplication.java123456789101112package com.javazhan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class RunApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RunApplication.class, args) ; &#125;&#125; 源码下载SpringBoot进阶之访问数据库（含源码）]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JdbcTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot进阶之模板引擎]]></title>
    <url>%2F2018%2F04%2F11%2FSpringBoot%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.html</url>
    <content type="text"><![CDATA[在动态HTML实现上Spring Boot依然可以完美胜任，并且提供了多种模板引擎的默认配置支持，所以在推荐的模板引擎下，我们可以很快的上手开发动态网站。 模板引擎种类Spring Boot提供了默认配置的模板引擎主要有以下几种： Thymeleaf FreeMarker Velocity Groovy Mustache 当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。 ThymeleafThymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。 在Spring Boot中使用Thymeleaf，只需要引入下面依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 案例-遍历所有学生信息 效果图： 工程结构 root package结构：com.example.myproject 应用主类Application.java置于rootpackage下，通常我们会在应用主类中做一些框架配置扫描等配置，我们放在root package下可以帮助程序减少手工配置来加载到我们希望被Spring加载的内容 实体（Entity）与数据访问层（Repository）置于com.example.myproject.domain包下 逻辑层（Service）置于com.example.myproject.service包下 Web层（web）置于com.example.myproject.web包下 实体类 Student .java1234567891011121314151617181920212223242526272829303132package com.javazhan.domain;public class Student &#123; private int id ; private String name ; private int age ; private String address ; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; web层 StudentController .java1234567891011121314151617181920212223242526272829package com.javazhan.controller;import java.util.ArrayList;import java.util.List;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import com.javazhan.domain.Student;@Controllerpublic class StudentController &#123; @RequestMapping("/getStudentList") public String getStudentList(ModelMap map) &#123; List&lt;Student&gt; list = new ArrayList&lt;Student&gt;() ; for(int i=0; i&lt;=5; i++) &#123; Student st = new Student() ; st.setId(i+1) ; st.setName("章三"+(i+1)) ; st.setAge(20+i) ; st.setAddress("北京故宫门牌号20"+i) ; list.add(st) ; &#125; map.addAttribute("list", list); return "index" ; &#125;&#125; 启动类 RunApplication.java123456789101112package com.javazhan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class RunApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RunApplication.class, args) ; &#125;&#125; 页面 index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org" lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt;&lt;/meta&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;/meta&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;/meta&gt; &lt;title&gt;学生信息&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"&gt;&lt;/link&gt; &lt;link rel="stylesheet" type="text/css" href="/css/style.css"&gt;&lt;/link&gt; &lt;link rel="stylesheet" type="text/css" href="/css/font-awesome.min.css"&gt;&lt;/link&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 内容 --&gt;&lt;div class="container"&gt; &lt;br&gt;&lt;/br&gt; &lt;div class="panel panel-warning"&gt; &lt;div class="panel-heading"&gt;&lt;span class="text-size"&gt;&lt;i class="icon-link"&gt;&lt;/i&gt; 学生所有信息&lt;/span&gt;&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each="list : $&#123;list&#125;"&gt; &lt;td th:text="$&#123;list.id&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;list.name&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;list.age&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;list.address&#125;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 内容 --&gt;&lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt;&lt;script type="text/javascript" src="/js/jquery-1.11.2.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 更多使用技巧请查看Thymeleaf官网文档 若想修改默认参数配置参考如下，如缓存，编码，修改默认的模板路径等。 123456789101112131415161718# Enable template caching.spring.thymeleaf.cache=true # Check that the templates location exists.spring.thymeleaf.check-template-location=true # Content-Type value.spring.thymeleaf.content-type=text/html # Enable MVC Thymeleaf view resolution.spring.thymeleaf.enabled=true # Template encoding.spring.thymeleaf.encoding=UTF-8 # Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.excluded-view-names= # Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.mode=HTML5 # Prefix that gets prepended to view names when building a URL.spring.thymeleaf.prefix=classpath:/templates/ # Suffix that gets appended to view names when building a URL.spring.thymeleaf.suffix=.html spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved. 源码下载SpringBoot进阶之模板引擎源码]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot入门之Web开发]]></title>
    <url>%2F2018%2F04%2F11%2FSpringBoot%E5%85%A5%E9%97%A8%E4%B9%8BWeb%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[静态资源目录Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：1234/static/public/resources/META-INF/resources 配置文件Spring Boot项目使用一个全局的配置文件application.properties或者是application.yml，在resources目录下或者类路径下的/config下，一般我们放到resources下。 修改tomcat端口配置 1server.port=8888 修改Spring MVC拦截路径规则默认Spring MVC拦截路径规则是/，如果要修改成*.html的话，可以在全局配置文件中进行如下设置： 1server.servlet-path=*.html 视图解析器配置一样的，Spring Boot也可以通过全局配置文件对视图解析器进行配置： 12spring.mvc.view.prefix=/WEB-INF/views/spring.mvc.view.suffix=.jsp 日志输出Spring Boot对各种日志框架都做了支持，我们可以通过配置来修改默认的日志的配置： 12#设置日志级别logging.level.org.springframework=DEBUG application.yml properties与yml文件在形式上有所差别，yml文件的书写方式比较简洁，类似eclipse中package的flag呈现方式（而properties文件则像Hierarchical方式）。如上面properties文件中的属性配置使用yml文件来写： 1234567891011121314server: port: 8888 context-path: /spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsplogging: level: org: springframework: debug 注：推荐使用yml文件在书写，需要注意一个地方：冒号与值中间是存在空格的！ Spring Boot的全局配置很强大，同时它可以配置的属性也很多，以上只列出几个常用的属性配置，如需查看完整的全局属性配置，请到spring-boot官方配置文档查看。 源码下载SpringBoot入门之Web开发源码]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot入门之HelloWorld]]></title>
    <url>%2F2018%2F04%2F11%2FSpringBoot%E5%85%A5%E9%97%A8%E4%B9%8BHelloWorld.html</url>
    <content type="text"><![CDATA[SpringBoot是什么？Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 SpringBoot优点？ 快速构建项目 对主流开发框架的无配置集成 项目可独立运行，无须外部依赖Servlet容器（Spring Boot默认自带了一个Tomcat） 提供运行时的应用监控 极大地提高了开发、部署效率 提供一系列大型企业级项目的功能性特性 那就开始我们的HelloWorld只需三步就完成我们的HelloWorld 第一步，我们新建一个Maven项目。给项目添加架包依赖，修改pom.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.javazhan&lt;/groupId&gt; &lt;artifactId&gt;sb01&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 第二步，新建一个类HelloWorldController .java 12345678910111213package com.javazhan.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloWorldController &#123; @RequestMapping("/helloworld") public String helloworld() &#123; return "HelloWorld!" ; &#125;&#125; 新建一个启动类RunApplication.java 1234567891011package com.javazhan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class RunApplication&#123; public static void main( String[] args )&#123; SpringApplication.run(RunApplication.class, args) ; &#125;&#125; 第三步，运行RunApplication.java，在浏览器输入地址http://localhost:8080/helloworld查看结果 知识点一般Spring Boot的Web应用都有一个xxxApplication类，并使用@SpringBootApplication注解标记，作为该web应用的加载入口。此外，还需要在main方法中(可以是任意一个类)使用SpringApplication.run(xxxApplication.class, args)来启动该web应用 源码下载SpringBoot入门之HelloWorld源码]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列1 工厂模式]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%971-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 使用场景 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 五种工厂模式1）简单工厂（静态）案例：生产车辆 抽象一个汽车基类，或者是接口123456public abstract class CarPrototype &#123; /** * 生产汽车 */ public abstract void produce();&#125; 生产奥迪汽车（具体的产品类） 123456789public class AodeCar extends CarPrototype &#123; @Override public void produce() &#123; // TODO Auto-generated method stub System.out.println("生产一辆奥迪汽车。。。。。。。。。。。。"); &#125;&#125; 生产宝马汽车（具体的产品类） 123456789public class BaomaCar extends CarPrototype &#123; @Override public void produce() &#123; // TODO Auto-generated method stub System.out.println("生产一辆宝马汽车。。。。。。。。。。。。"); &#125;&#125; 生产红旗汽车（具体的产品类） 123456789public class HongqiCar extends CarPrototype &#123; @Override public void produce() &#123; // TODO Auto-generated method stub System.out.println("生产一辆红旗汽车。。。。。。。。。。。。"); &#125;&#125; 汽车工厂（简单工厂类） 12345678910111213141516public class SimpleCarFactory &#123; public static CarPrototype createCar(String type) &#123; switch(type) &#123; case "baoma": return new BaomaCar(); case "aode": return new AodeCar(); case "hongqi": return new HongqiCar(); default: throw new BaseException("工厂类无法匹配汽车，没法生产。。。。。"); &#125; &#125;&#125; 测试生产汽车 123456public class TestCarFactory &#123; public static void main(String[] args) &#123; CarPrototype carPrototype = new SimpleCarFactory().createCar("baoma"); carPrototype.produce(); &#125;&#125; 结果 1生产一辆宝马汽车。。。。。。。。。。。。 特点1 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。2 create()方法通常是静态的，所以也称之为静态工厂。缺点1 扩展性差（我想增加一种汽车，除了新增一个汽车产品类，还需要修改工厂类方法）2 不同的产品需要不同额外参数的时候 不支持。 2）简单工厂（反射）利用反射Class.forName(clz.getName()).newInstance()实现的简单工厂 12345678910111213public class ReflectionCarFactory &#123; public static &lt;T extends CarPrototype&gt; T createCar(Class&lt;T&gt; prototype) &#123; T result = null; try &#123; result = (T)Class.forName(prototype.getName()).newInstance(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return result; &#125;&#125; 测试简单工厂（反射） 123456789101112public class TestCarFactory &#123; public static void main(String[] args) &#123; // 简单工厂（静态） /*CarPrototype carPrototype = new SimpleCarFactory().createCar("baoma"); carPrototype.produce();*/ // 简单工厂（反射） CarPrototype carPrototype = ReflectionCarFactory.createCar(AodeCar.class); carPrototype.produce(); &#125;&#125; 结果 1生产一辆奥迪汽车。。。。。。。。。。。。 特点1 它也是一个具体的类，非接口 抽象类。但它的create()方法，是利用反射机制生成对象返回，好处是增加一种产品时，不需要修改create()的代码。缺点这种写法粗看牛逼，细想之下，不谈reflection的效率还有以下问题：1 个人觉得不好，因为Class.forName(clz.getName()).newInstance()调用的是无参构造函数生成对象，它和new Object()是一样的性质，而工厂方法应该用于复杂对象的初始化 ，当需要调用有参的构造函数时便无能为力了，这样像为了工厂而工厂。2 不同的产品需要不同额外参数的时候 不支持。 3）多方法工厂（常用）不同的产品需要不同额外参数的时候 不支持。而且如果使用时传递的type、Class出错，将不能得到正确的对象，容错率不高。而多方法的工厂模式为不同产品，提供不同的生产方法，使用时 需要哪种产品就调用该种产品的方法，使用方便、容错率高。 工厂如下 1234567891011121314151617181920212223public class ManyWayCarFactory &#123; /** * 生产奥迪汽车 * @return */ public static CarPrototype createAodeCar() &#123; return new AodeCar(); &#125; /** * 生产宝马汽车 * @return */ public static CarPrototype createBaomaCar() &#123; return new BaomaCar(); &#125; /** * 生产红旗汽车 * @return */ public static CarPrototype createHongqiCar() &#123; return new HongqiCar(); &#125;&#125; 测试多方法工厂（常用） 12345678910111213141516public class TestCarFactory &#123; public static void main(String[] args) &#123; // 简单工厂（静态） /*CarPrototype carPrototype = new SimpleCarFactory().createCar("baoma"); carPrototype.produce();*/ // 简单工厂（反射） /*CarPrototype carPrototype = ReflectionCarFactory.createCar(AodeCar.class); carPrototype.produce();*/ // 多方法静态工厂(模仿Executor类） CarPrototype carPrototype = new ManyWayCarFactory().createHongqiCar(); carPrototype.produce(); &#125;&#125; 结果 1生产一辆红旗汽车。。。。。。。。。。。。 4）普通工厂普通工厂就是把简单工厂中具体的工厂类，划分成两层：抽象工厂层+具体的工厂子类层。（一般-&gt;特殊） 汽车工厂（抽象工厂类），作用就是生产汽车： 123public abstract class CarFactory &#123; public abstract CarPrototype create();&#125; 生产奥迪工厂（具体工厂子类） 12345678public class AodeFactory extends CarFactory &#123; public CarPrototype create() &#123; // TODO Auto-generated method stub return new AodeCar(); &#125; &#125; 生产宝马工厂（具体工厂子类） 12345678public class BaomaFactory extends CarFactory &#123; public CarPrototype create() &#123; // TODO Auto-generated method stub return new BaomaCar(); &#125; &#125; 生产红旗工厂（具体工厂子类） 12345678public class HongqiFactory extends CarFactory &#123; public CarPrototype create() &#123; // TODO Auto-generated method stub return new HongqiCar(); &#125; &#125; 测试普通工厂1234567891011121314151617181920public class TestCarFactory &#123; public static void main(String[] args) &#123; // 简单工厂（静态） /*CarPrototype carPrototype = new SimpleCarFactory().createCar("baoma"); carPrototype.produce();*/ // 简单工厂（反射） /*CarPrototype carPrototype = ReflectionCarFactory.createCar(AodeCar.class); carPrototype.produce();*/ // 多方法静态工厂(模仿Executor类） /*CarPrototype carPrototype = new ManyWayCarFactory().createHongqiCar(); carPrototype.produce();*/ // 普通工厂 CarPrototype carPrototype = new BaomaFactory().create(); carPrototype.produce(); &#125;&#125; 结果 1生产一辆宝马汽车。。。。。。。。。。。。 普通工厂与简单工厂模式的区别：可以看出，普通工厂模式特点：不仅仅做出来的产品要抽象， 工厂也应该需要抽象。工厂方法使一个产品类的实例化延迟到其具体工厂子类。工厂方法的好处就是更拥抱变化。当需求变化，只需要增删相应的类，不需要修改已有的类。而简单工厂需要修改工厂类的create()方法，多方法静态工厂模式需要增加一个静态方法。缺点：引入抽象工厂层后，每次新增一个具体产品类，也要同时新增一个具体工厂类，所以我更青睐 多方法静态工厂。 5）抽象工厂以上介绍的工厂都是单产品系的。抽象工厂是多产品系 （貌似也有产品家族的说法）。举个例子来说，每个店(工厂)不仅仅生产汽车，还生产零件。 生产零件，零件是产品，先抽象一个产品类，零件：123456public abstract class ComponentsPrototype &#123; /** * 生产零件 */ public abstract void produce();&#125; 生产车门123456789public class CarDoorComponents extends ComponentsPrototype &#123; @Override public void produce() &#123; // TODO Auto-generated method stub System.out.println("生产车门-------------"); &#125;&#125; 生产发动机123456789public class EngineComponents extends ComponentsPrototype &#123; @Override public void produce() &#123; // TODO Auto-generated method stub System.out.println("生产发动机-------------"); &#125;&#125; 抽象汽车工厂（抽象工厂类）123456789101112public abstract class AbstractCarFactory &#123; /** * 生产汽车 * @return */ public abstract CarPrototype createCar(); /** * 生产零件 * @return */ public abstract ComponentsPrototype createComponents();&#125; 测试抽象工厂 1234567891011121314151617181920212223242526public class TestCarFactory &#123; public static void main(String[] args) &#123; // 简单工厂（静态） /*CarPrototype carPrototype = new SimpleCarFactory().createCar("baoma"); carPrototype.produce();*/ // 简单工厂（反射） /*CarPrototype carPrototype = ReflectionCarFactory.createCar(AodeCar.class); carPrototype.produce();*/ // 多方法静态工厂(模仿Executor类） /*CarPrototype carPrototype = new ManyWayCarFactory().createHongqiCar(); carPrototype.produce();*/ // 普通工厂 /*CarPrototype carPrototype = new BaomaFactory().create(); carPrototype.produce();*/ // 抽象工厂 CarPrototype carPrototype = new ChinaCarFactory().createCar(); carPrototype.produce(); ComponentsPrototype componentsPrototype = new ChinaCarFactory().createComponents(); componentsPrototype.produce(); &#125;&#125; 结果12生产一辆宝马汽车。。。。。。。。。。。。生产发动机-------------]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装NodeJs]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%AE%89%E8%A3%85NodeJs.html</url>
    <content type="text"><![CDATA[下载Node.js去官网官网：https://nodejs.org/en/download/ 下载后 ftp上传或者命令下载压缩包1wget https://nodejs.org/dist/v8.10.0/node-v8.10.0-linux-x64.tar.xz 解压12[root@localhost home]# tar -xJf node-v8.10.0-linux-x64.tar.xz[root@localhost home]# cd /usr/local/data/node-v8.10 配置1vi /etc/profile 在最后加上：12export NODE_HOME=/usr/local/data/node-v8.10export PATH=$NODE_HOME/bin:$PATH 让环境变量生效1[root@localhost node-v8.10]# source /etc/profile 新版本都有自己npm 所以不需要再安装了 测试1234[root@localhost node-v8.10]# node -vv8.10.0[root@localhost node-v8.10]# npm -v5.6.0]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
</search>
