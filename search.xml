<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分布式架构 - 微服务框架Dubbo]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6Dubbo.html</url>
    <content type="text"><![CDATA[Dubbo 的背景随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。 单一应用架构：当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 此时，用于简化增删改查工作量的数据访问框架（ORM）是关键。 垂直应用架构：当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 此时，用于加速前端页面开发的Web框架（MVC）是关键。 分布式服务架构：当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 此时，用于提高业务复用及整合的分布式服务框架（RPC）是关键。 流动计算架构：当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键。 什么是 DubboDubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，SOA 服务治理方案。 简单的说，dubbo 就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有 dubbo 这样的分布式服务框架的需求。 并且本质上是个服务调用，说白了就是个远程服务调用的分布式框架（告别 Web Service 模式中的 wsdl,以服务者与消费者的方式在 dubbo 上注册）。 其核心部分包含: 1.远程通讯: 提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。 2.集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 3.自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 Dubbo能做什么具体能做什么： 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 总结：Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 Spring 的 Schema 扩展进行加载。 Dubbo 架构Dubbo 已进入 Apache 孵化器。Apache Dubbo官网地址 节点角色说明： Provider: 暴露服务的服务提供方。 Consumer: 调用远程服务的服务消费方。 Registry: 服务注册与发现的注册中心。 Monitor: 统计服务的调用次调和调用时间的监控中心。 Container: 服务运行容器。 调用关系说明： 0.服务容器负责启动，加载，运行服务提供者。 1.服务提供者在启动时，向注册中心注册自己提供的服务。 2.服务消费者在启动时，向注册中心订阅自己所需的服务。 3.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 更多详细教程可参考官方文档 持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>架构</tag>
        <tag>微服务</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构 - Spring Cloud]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-Spring-Cloud.html</url>
    <content type="text"><![CDATA[什么是微服务Spring Cloud 是 Spring 旗下的项目之一，Spring Cloud 官网地址：http://projects.spring.io/spring-cloud/ Spring 最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。Spring Cloud 也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： Spring Cloud Netflix Eureka：注册中心 Zuul：服务网关 Ribbon：负载均衡 Feign：服务调用 Hystix：熔断器 Spring Cloud Config：由 git 存储库支持的集中式外部配置管理。 Spring Cloud Bus：用于将服务和服务实例与分布式消息相连接的事件总线，在集群中传播状态变化（例如配置更改事件）。持续更新中…]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构 - Spring Boot]]></title>
    <url>%2F2018%2F06%2F14%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-Spring-Boot.html</url>
    <content type="text"><![CDATA[什么是SpringBootSpringBoot 是 Spring 项目中的一个子工程，与我们所熟知的 Spring-framework 同属于 spring 的产品。 我们可以看到下面的一段介绍： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把 Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的 spring 项目，并且尽可能的减少一切 xml 配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 为什么要学习SpringBootjava 一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能 Python 程序员已经把功能写好了，究其原因注意是两点： 复杂的配置 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 我们可以使用 SpringBoot 创建 java 应用，并使用java –jar启动它，就能得到一个生产级别的 web 工程。 SpringBoot的优点Spring Boot 主要目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验。 开箱即用（启动器 starter-其实就是 SpringBoot 提供的一个 jar 包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等。 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到Spring boot 官网查看。 快速入门创建工程创建 maven 名为 springboot-demo 的 Spring Boot 工程。 添加依赖123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.github.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写启动类123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 编写 controller12345678@RestControllerpublic class HelloController &#123; @GetMapping("hello") public String hello()&#123; return "hello, spring boot!"; &#125;&#125; 更多技能 Spring boot 整合 mybatis Spring boot 整合 jpa Spring boot 整合 redis Spring boot 整合 MQ Spring boot 整合 … 更多细节，大家可以到Spring boot 官网查看。]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统 - 内存数据库Redis]]></title>
    <url>%2F2018%2F05%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93Redis.html</url>
    <content type="text"><![CDATA[什么是 NoSqlNoSQL，即 Not-Only SQL，泛指非关系型的数据库。它是为了解决高并发、高可用、高可扩展、大数据存储问题而产生的数据库解决方案。NoSQL 可以作为关系型数据库的良好补充，但是不能替代关系型数据库。 NoSql 数据库分类键值(Key-Value)存储数据库相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 列存储数据库相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库相关产品：CouchDB、MongoDB典型应用：Web 应用（与 Key-Value 类似，Value 是结构化的）数据模型： 一系列键值对优势：数据结构要求不严格劣势：查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 Redis 是什么Redis 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止 Redis 支持的键值数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型 Redis 的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等）。 分布式集群架构中的 session 分离。 聊天室的在线好友列表。 任务队列。（秒杀、抢购、12306 等等） 应用排行榜。 网站访问统计。 数据过期处理（可以精确到毫秒） 持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>系统</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式架构 - Nginx]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-Nginx.html</url>
    <content type="text"><![CDATA[什么是 NginxNginx 是俄罗斯人编写的一款高性能的 HTTP 和反向代理服务器。 在高连接并发的情况下，它能够支持高达 50000 个并发连接数的响应，但是内存、CPU 等系统资源消耗却很低，运行很稳定。 Nginx 的优势选择 Nginx 的理由也很简单： 第一，它可以支持5W高并发连接； 第二，内存消耗少； 第三，成本低，如果采用 F5、NetScaler 等硬件负载均衡设备的话，需要大几十万。而 Nginx 是开源的，可以免费使用并且能用于商业用途。 分布式架构中的作用最常用的有三项： 路由功能（与微服务对应）：域名/路径，进行路由选择后台服务器； 负载功能（与高并发高可用对应）：对后台服务器集群进行负载； 静态服务器（比 Tomcat 性能高很多）：在 mvvm 模式中，充当文件读取职责。 总结：实际使用中，这三项功用，会混合使用。比如先分离动静，再路由服务，再负载机器。 代理正向代理：客户端自己请求出现困难。客户请了一个代理，来代自己做事，就叫代理。比如代理律师，代购，政府机关办事的代理人等等。反向代理：服务端推出的一个代理招牌。 Nginx 安装源码编译方式一般系统中已经装了了 make 和 g++，无须再装。1234# 安装 makeyum -y install autoconf automake make# 安装 g++yum -y install gcc gcc-c++ 安装nginx依赖的库123456# 安装 pcre yum -y install pcre pcre-devel# 安装 zlib yum -y install zlib zlib-devel# 安装 openssl yum install -y openssl openssl-devel Nginx 官方下载地址 安装 Nginx 123456789# 下载 Nginxwget http://nginx.org/download/nginx-1.16.0.tar.gz# 解压 Nginxtar -zxvf nginx-1.16.0.tar.gzcd nginx-1.16.0# 安装 HTTPS 模块./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module# 安装make &amp;&amp; make install --prefix 指定安装目录--with-http_ssl_module 安装 HTTPS 模块make 编译make install 安装 yum 方式Linux 系统下：123# yum扩展源yum install epel-release -yyum install nginx -y 目录结构 Conf：配置文件 Html：网页文件 Logs：日志文件 Sbin：二进制程序 启停命令./nginx -c nginx.conf的文件。如果不指定，默认为 NGINX_HOME/conf/nginx.conf./nginx -s stop 停止./nginx -s quit 退出./nginx -s reload 重新加载 nginx.conf 发送信号的方式kill -QUIT 进程号 安全停止kill -TERM 进程号 立即停止 配置文件Nginx 全局属性的配置12345678910111213#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125; user：主模块命令， 指定Nginx的worker进程运行用户以及用户组，默认由 nobody 账号运行。worker_processes: 指定 Nginx 要开启的进程数。error_log：用来定义全局错设日志文件的路径和日志名称。日志输出级别有 debug，info，notice，warn，error，crit 可供选择，其中 debug 输出日志最为详细，而 crit（严重）输出日志最少。默认是 error。 pid: 用来指定进程 id 的存储文件位置。event：设定 nginx 的工作模式及连接数上限，其中参数 use 用来指定 nginx 的工作模式（这里是 epoll，epoll 是多路复用 IO(I/O Multiplexing)中的一种方式）,nginx 支持的工作模式有 select ,poll,kqueue,epoll,rtsig,/dev/poll。其中 select 和 poll 都是标准的工作模式，kqueue 和 epoll 是高效的工作模式，对于 linux 系统，epoll 是首选。 worker_connection：是设置 nginx 每个进程最大的连接数，默认是1024，所以nginx最大的连接数 max_client=worker_processes * worker_connections。进程最大连接数受到系统最大打开文件数的限制，需要设置 ulimit。 http 服务器相关属性的配置1234567891011121314151617http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; include：主模块命令，对配置文件所包含文件的设定，减少主配置文件的复杂度，相当于把部分设置放在别的地方，然后在包含进来，保持主配置文件的简洁。default_type：默认文件类型，当文件类型未定义时候就使用这类设置的。log_format：设定日志格式。sendfile：开启高效文件传输模式（zero copy 方式），避免内核缓冲区数据和用户缓冲区数据之间的拷贝。tcp_nopush：开启 TCP_NOPUSH 套接字（sendfile 开启时有用）keepalive_timeout：客户端连接超时时间gzip：设置是否开启 gzip 模块 server 段虚拟主机的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125;&#125; listen：虚拟主机的服务端口server_name：用来指定ip或者域名，多个域名用逗号分开charset：设置字符编码location /：默认请求 root：虚拟主机的网页根目录 index：默认访问首页文件error_page：定义错误提示页面location ~ .php$：PHP 脚本请求全部转发到 FastCGI 处理.，使用FastCGI默认配置。location ~ /.ht：禁止访问 .htxxx 文件 Nginx 日志描述通过访问日志，你可以得到用户地域来源、跳转来源、使用终端、某个URL访问量等相关信息；通过错误日志，你可以得到系统某个服务或server的性能瓶颈等。 因此，将日志好好利用，你可以得到很多有价值的信息。 日志格式打开nginx.conf配置文件：vi /usr/local/nginx/conf/nginx.conf日志部分内容：#access_log logs/access.log main; 日志生成的到 Nginx 根目录 logs/access.log 文件，默认使用 main 日志格式，也可以自定义格式。 参数明细表 参数 说明 $remote_addr 客户端的ip地址(代理服务器，显示代理服务ip) $remote_user 用于记录远程客户端的用户名称（一般为“-”） $time_local 用于记录访问时间和时区 $request 用于记录请求的url以及请求方法 $status 响应状态码，例如：200成功、404页面找不到等。 $body_bytes_sent 给客户端发送的文件主体内容字节数 $http_user_agent 用户所使用的代理（一般为浏览器） $http_x_forwarded_for 可以记录客户端IP，通过代理服务器来记录客户端的ip地址 $http_referer 可以记录用户是从哪个链接访问过来的 查看日志命令 tail -f /usr/local/nginx/logs/access.log持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>架构</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
</search>
