<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分布式技术 Thymeleaf 页面静态化]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF-Thymeleaf-%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96.html</url>
    <content type="text"><![CDATA[什么是 ThymeleafThymeleaf 是一个适用于 Web 和独立环境的现代服务器端 Java 模板引擎。 Thymeleaf的主要目标是将优雅的自然模板带到开发工作流程中，并将HTML在浏览器中正确显示，并且可以作为静态原型，让开发团队能更容易地协作。 Thymeleaf 也是 Spring 官方推荐的模板引擎。 本篇内容主要讲解页面静态化，关于 Thymeleaf 语法，大家可以去官方文档去学习。 Thymeleaf 官方文档 什么是静态化静态化是指把动态生成的 HTML 页面变为静态内容保存，以后用户的请求到来，直接访问静态页面，不再经过服务的渲染。 而静态的HTML页面可以部署在nginx中，从而大大提高并发能力，减小tomcat压力。 为什么要静态化我们的页面是通过 Thymeleaf 模板引擎渲染后返回到客户端。在后台需要大量的数据查询，而后渲染得到 HTML 页面。会对数据库造成压力，并且请求的响应时间过长，并发能力不高。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>Thymeleaf</tag>
        <tag>页面静态化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全文搜索引擎 Elasticsearch]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-ElasticSearch.html</url>
    <content type="text"><![CDATA[Elasticsearch 是什么Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。 Elasticsearch 官方地址 Elasticsearch 的优点 分布式，无需人工搭建集群（solr 就需要人为配置，使用 Zookeeper 作为注册中心） Restful 风格，一切 API 都遵循 Rest 原则，容易上手 近实时搜索，数据更新在 Elasticsearch 中几乎是完全同步的。 Elasticsearch 应用场景 大型分布式日志分析系统：如 ELK （Elasticsearch(存储日志)+logstash(收集日志)+kibana(展示数据)） 大型分布式搜索系统：如电商商品搜索，网盘搜索引擎 Elasticsearch 存储结构Elasticsearch是文件存储，Elasticsearch是面向文档型数据库，一条数据在这里就是一个文档，用JSON作为文档序列化的格式。 1234567891011&#123; "name": "John", "sex": "Male", "age": 25, "birthDate": "2019/06/10", "about": "I love to go rock climbing", "interests":[ "sports", "music" ]&#125; 关系数据库 ⇒ 数据库 ⇒ 表 ⇒ 行 ⇒ 列(Columns)Elasticsearch ⇒ 索引(Index) ⇒ 类型(type) ⇒ 文档(Docments) ⇒ 字段(Fields) Elasticsearch 安装安装 jdk 由于 Elasticsearch 是由 Java 语言编写依赖 jdk。安装略。 elasticsearch-7.2.0 需要 jdk11 下载 Elasticsearch 安装包 官方地址 解压 Elasticsearch 12tar -zxvf elasticsearch-7.2.0-linux-x86_64.tar.gzmv elasticsearch-7.2.0 /home/data/elastic 修改 jvm.options 默认配置占用内存过大，修改512m config/jvm.options12-Xms512m-Xmx512m 修改 elasticsearch.yml 允许外网连接配置config/elasticsearch.yml12345678# 数据目录位置需要新增path.data: /home/data/elastic/data# 日志目录位置需要新增path.logs: /home/data/elastic/data# 绑定到0.0.0.0，允许任何ip来访问network.host: 192.168.2.129# 对外服务的http端口，默认为9200http.port: 9200 启动 Elasticsearch 因为安全问题 Elasticsearch 不让用 root 用户直接运行，所以要创建新用户。 创建用户：useradd elastic 给用户赋权：chown -R elastic:elastic /home/data/elastic/ 切换用户启动123su elasticcd /home/data/elastic/elasticsearch-7.2.0/bin./elasticsearch 测试 Elasticsearch curl http://localhost:9200 或者浏览器：http://192.168.2.129:9200 1234567891011121314151617&#123; name: "bogon", cluster_name: "elasticsearch", cluster_uuid: "_na_", version: - &#123; number: "7.2.0", build_flavor: "default", build_type: "tar", build_hash: "508c38a", build_date: "2019-06-20T15:54:18.811730Z", build_snapshot: false, lucene_version: "8.0.0", minimum_wire_compatibility_version: "6.8.0", minimum_index_compatibility_version: "6.0.0-beta1" &#125;, tagline: "You Know, for Search"&#125; 常见错误 [1]: max number of threads [1024] for user [elastic] is too low, increase to at least [4096] 解决方法：用户线程数不够，修改配置 vim /etc/security/limits.d/20-nproc.conf 1* soft nproc 4096 其它百度都能找到 Spring Boot 整合 Elasticsearch持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企业级容器 Docker]]></title>
    <url>%2F2019%2F05%2F28%2F%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%B9%E5%99%A8-Docker.html</url>
    <content type="text"><![CDATA[什么是 DockerDocker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现 虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 什么是虚拟化虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。 虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件对资源充分利用。 为什么要用 Docker 上手快 职责的逻辑分类 快速高效的开发生命周期 鼓励使用面向服务的架构 容器与虚拟机比较容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker 优势体现为启动速度快、占用体积小。 Docker 组件Docker 服务器与客户端 Docker 是一个客户端-服务器（C/S）架构程序。 Docker 客户端只需要向 Docker 服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。 Docker 提供了一个命令行工具 Docker 以及一整套 RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 Docker 镜像与容器 镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义。 从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是 Docker 内部的实现细节，并且能够 在主机（译者注：运行 Docker 的机器）的文件系统上访问到。 统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。 你可以在你的主机文件系统上找到有关这些层的文件。需要注意的是，在一个运行中的容器内部，这些层是不可见的。在我的主机上，我发现它们存在于/var/lib/docker/aufs目录下。 容器（container）的定义和镜像（image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 细心的读者可能会发现，容器的定义并没有提及容器是否在运行，没错，这是故意的。正是这个发现帮助我理解了很多困惑。 要点：容器 = 镜像 + 可读层。并且容器的定义并没有提及是否要运行容器。 总结 镜像是构建 Docker 的基石。用户基于镜像来运行自己的容器。镜像也是 Docker 生命周期中的“构建”部分。 镜像是基于统一文件系统的一种层式结构，由一系列指令一步一步构建出来。 镜像当作容器的”源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 容器（container）的定义和镜像（image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 Registry（注册中心） Docker 用 Registry 来保存用户构建的镜像。Registry 分为公共和私有两种。Docker 公司运营公共的 Registry 叫做 Docker Hub。用户可以在 Docker Hub 注册账号，分享并保存自己的镜像（说明：在 Docker Hub 下载镜像巨慢，可以自己构建私有的 Registry）。 https://hub.docker.com/ 安装 DockerDocker 官方建议在 Ubuntu 中安装，因为 Docker 是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。 ​注意：这里建议安装在CentOS7.x以上的版本。 安装 1234567891011# yum 包更新到最新sudo yum update# 安装需要的软件包， yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 设置 yum 源为阿里云sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 安装 dockersudo yum install docker-ce# 安装后查看 docker 版本docker -v 设置ustc的镜像 ustc 是老牌的 linux 镜像服务提供者了，还在遥远的 ubuntu 5.04 版本的时候就在用。ustc 的 docker 镜像加速器速度很快。ustc docker mirror 的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件：vi /etc/docker/daemon.json123&#123; "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]&#125; Docker的启动与停止 systemctl 命令是系统服务管理器指令1234567891011121314# 启动 dockersystemctl start docker# 停止 dockersystemctl stop docker# 重启 dockersystemctl restart docker# 查看 docker 状态systemctl status docker# 开机启动systemctl enable docker# 查看 docker 概要信息docker info# 查看 docker 帮助文档docker --help 常用命令镜像相关命令 查看镜像1docker images 搜索镜像1docker search 镜像名称 拉取镜像 1docker pull 镜像名称 删除镜像 1234# 按镜像ID删除镜像docker rmi 镜像ID# 删除所有镜像docker rmi `docker images -q` 容器相关命令 查看正在运行的容器 1docker ps 查看所有容器 1docker ps –a 查看最后一次运行的容器 1docker ps –l 查看停止的容器 1docker ps -f status=exited 创建与启动容器 创建容器命令1docker run 停止容器 1docker stop 容器名称（或者容器ID） 启动容器 1docker start 容器名称（或者容器ID） 文件拷贝 如果我们需要将文件拷贝到容器内可以使用cp命令 1docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 1docker cp 容器名称:容器目录 需要拷贝的文件或目录 删除指定的容器 1docker rm 容器名称（容器ID） 应用部署MySQL 部署 1234# 拉取 mysql 镜像docker pull centos/mysql-57-centos7# 创建容器docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 Tomcat 部署 1234# 拉取镜像docker pull tomcat:7-jre7# 创建容器 -p表示地址映射docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 Nginx 部署 1234# 拉取镜像 docker pull nginx# 创建 Nginx 容器docker run -di --name=mynginx -p 80:80 nginx Redis 部署 1234# 拉取镜像 docker pull redis# 创建容器docker run -di --name=myredis -p 6379:6379 redis 迁移与备份镜像备份 12345# 容器保存为镜像docker commit mynginx mynginx_i# 镜像备份docker save -o mynginx.tar mynginx_i 首先我们先删除掉 mynginx_img 镜像，然后执行此命令进行恢复 12# 镜像恢复与迁移docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 更多教程可以参考官方文档，大家可以去Docker 官方地址 持续更新中…]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>Docker</tag>
        <tag>企业级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb 开发经验 02]]></title>
    <url>%2F2019%2F04%2F26%2FJavaWeb-%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-02.html</url>
    <content type="text"><![CDATA[java 对象转成 JSON 字符串，出现 $ref原因：List 里含有重复对象使用：DisableCircularReferenceDetect 来禁止循环引用检测 1JSON.toJSONString(list, SerializerFeature.DisableCircularReferenceDetect) 引用是通过$ref来表示的 引用 描述 “$ref”:”..” 上一级 “$ref”:”@” 当前对象，也就是自引用 “$ref”:”$” 根对象 “$ref”:”$.children.0” 基于路径的引用，相当于 root.getChildren().get(0) freemarker 判断对象是否为空12345&lt;#if name??&gt;$&#123;name &#125;&lt;/#if&gt;$&#123;name!'' &#125; button 标签（问题：回车会提交的）submit 该按钮是提交按钮（除了 Internet Explorer，该值是其他浏览器的默认值） 校验手机格式由于运营商号段随时会变，故采取非严谨的规则。 Java 版本 12345678910/** * 校验手机号 * @param number * @return */private boolean checkPhoneNumber(String number) &#123; String regex = "^[1]([3-9])[0-9]&#123;9&#125;$"; Pattern pattern = Pattern.compile(regex); return pattern.matcher(number).matches();&#125; JS 版本 1234var telStr = "/^[1]([3-9])[0-9]&#123;9&#125;$/";if (!(telStr.test(number))) &#123; console.log("手机号格式不合法");&#125; CSS 怎么引用字体包加入一下代码，css 直接引用字体名称即可。 1234@font-face &#123; font-family: 'MyNewFont'; /*字体名称*/ src: url('font.ttf'); /*字体源文件*/&#125; 解决引入外网资源 403 forbidden 问题页面中引入外网的链接资源，会产生一个新的 Http 清求。为了安全（URL 里可能包含用户信息），浏览器一般都会在请求头加上 referrer 字段表示来源的。 所以，此时我们要隐藏外部链接中的 referrer，在 head 标签中加入 meta，代码如下 1&lt;meta name="referrer" content="no-referrer"&gt; Float 和 Double 的精度缺失问题Float 和 Double 数据进行运算会出现精度丢失问题。解决方法： 避免小数的使用 使用 BigDecimal 的 String 构造函数 123456789double dis = 6*0.1D;System.out.println(dis); // 0.6000000000000001// 第一种double dis2 = 6/10D;System.out.println(dis2); // 0.6// 第二种BigDecimal bigDecimal = new BigDecimal("6");BigDecimal bigDecimal2 = new BigDecimal("0.1");System.out.println(bigDecimal.multiply(bigDecimal2)); // 0.6 IDEA 删除文件问题描述 删除一个为指定类型的文件（默认文本 text），再次新建相同的文件时则会默认到之前的文件类型。 彻底删除方法 打开 Setting 找到 File Type 找到 Recognized File Types 框中的 Text 下拉 Registered Patterns 框到最后，就找到之前新建的文件 删除即可 持续更新中…]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>开发经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb 开发经验 01]]></title>
    <url>%2F2019%2F04%2F20%2FJavaWeb-%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-01.html</url>
    <content type="text"><![CDATA[Set 无序不重复可用于比较对象Set 里的元素无放入顺序，元素不可重复。 123456Person person1 = new Person("张三", "男", 20);Person person2 = new Person("张三", "男", 20);Set&lt;Person&gt; hasSet = new HashSet&lt;&gt;();hasSet.add(person1);hasSet.add(person2);System.out.println(hasSet.size()); 字符串转 List&lt;Class&gt;使用的是 JSONArray.parseArray 而不是 JSONArray.parseObject 1List&lt;Mobile&gt; mobiles = (List&lt;Mobile&gt;) JSONArray.parseArray(str, Mobile.class); 关于ajaxupload.js上传图片问题谷歌浏览器慎用有道词典，有道词典会导致body里面多一个元素&lt;audio controls=&quot;controls&quot; style=&quot;display: none;&quot;&gt;&lt;/audio&gt; 大多数的上传插件，为了实现无刷新页面上传，通常都会构建一个虚拟的 iframe 和 form，比如 ajaxupload，它会把 form 的 target 属性指定为 iframe 中的 name 值，目的是指定返回的页面在哪里打开，上传一般都是返回的 json 字符串，所以这时候返回 json 字符串就会被添加到 iframe 的 body 中，再获取 iframe 中 body 的值作为上传文件的返回结果。有道词典会在返回结果中多了一行&lt;audio controls=&quot;controls&quot; style=&quot;display: none;&quot;&gt;&lt;/audio&gt; 可以关掉插件 更换浏览器 Json字符串有转义字符分析：Json 多次转String会产生转义字符如&quot;，\解决方法：封装方法。123456789/** * 处理 json 字符串多出前后双引号和转义符 * @param rspStr * @return */public static String jsonRemoveEscaping(String rspStr) &#123; rspStr = rspStr.replace("\\","").replace("\"&#123;","&#123;").replace("&#125;\"","&#125;"); return rspStr;&#125; 携程 Apollo 配置中心本地启动 注意事项 一般只需要在/opt/settings/server.properties中配置了 env=DEV 就可以直接直接启动（因为 Client 在本地仓库的包上已经有了 meta_server 的信息） IDE 上也可以通过指定 VM 的参数，增加系统属性变量 -D 来实现调试 1-Denv=DEV -Ddev_meta=http://10.20.25.119:18020 判断线程池执行完，再执行下一步 isShutDown当调用shutdown()或shutdownNow()方法后返回为true。 isTerminated当调用shutdown()方法后，并且所有提交的任务完成后返回为true; isTerminated当调用shutdownNow()方法后，成功停止后返回为true; 如果线程池任务正常完成，都为false 123456789101112131415161718192021222324252627List&lt;Integer&gt; typeList = new ArrayList&lt;&gt;(); typeList.add(1); typeList.add(2); typeList.add(3);ExecutorService pool = Executors.newFixedThreadPool(5);try &#123; for (final int type:typeList) &#123; pool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(type); &#125; &#125;); &#125;&#125; finally &#123; if (pool != null) &#123; pool.shutdown(); &#125;&#125;while (!pool.isTerminated()) &#123; // 等待所有子线程结束&#125;System.out.println("end");// 或者// if(pool.isTerminated())&#123;执行完后，要执行的部分（这个会往后面继续走的）&#125; ibatis 查询日期会去掉时分秒 写 sql 的时候可以用 to_char 来转换 自定义转换 自定义转换 通过配置一个 TypeHandler，让 TypeHandler 在转换的时候把java.sql.Date转换成java.sql.Timestamp。 在 sqlMapConfig 中配一下: 1&lt;typeHandler javaType="object" callback="xxx.xxx.OracleObjectTypeHandler"/&gt; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class OracleObjectTypeHandler extends BaseTypeHandler implements TypeHandler &#123; public Object getResult(ResultSet rs, String columnName) throws SQLException &#123; Object object = rs.getObject(columnName); if (rs.wasNull()) &#123; return null; &#125; else &#123; boolean b = object instanceof java.sql.Date; if (b) object = new Date(rs.getTimestamp(columnName).getTime()); return object; &#125; &#125; public Object getResult(ResultSet rs, int columnIndex) throws SQLException &#123; Object object = rs.getObject(columnIndex); if (rs.wasNull()) &#123; return null; &#125; else &#123; boolean b = object instanceof java.sql.Date; if (b) object = new Date(rs.getTimestamp(columnIndex).getTime()); return object; &#125; &#125; public Object getResult(CallableStatement cs, int columnIndex) throws SQLException &#123; Object object = cs.getObject(columnIndex); if (cs.wasNull()) &#123; return null; &#125; else &#123; boolean b = object instanceof java.sql.Date; if (b) object = new Date(cs.getTimestamp(columnIndex).getTime()); return object; &#125; &#125; public Object valueOf(String s) &#123; return s; &#125; public void setParameter(PreparedStatement ps, int i, Object parameter, String jdbcType) throws SQLException &#123; ps.setObject(i, parameter); &#125;&#125; SpringMvc 表单提交时 date 类型form表单中的数据是基本类型的，对时间类型是不支持的 方法一：在对应的 Controller 中新增下面的方法（针对一个类） 12345678910/** * form表单提交 Date类型数据绑定 * @param binder */ @InitBinder public void initBinder(WebDataBinder binder) &#123; SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); dateFormat.setLenient(false); binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true)); &#125; 方法二：在实体类中添加注解 12@DateTimeFormat(pattern="yyyy-MM-dd") private Date birthday; 注：配置&lt;mvc:annotation-driven/&gt;，默认就启用 FormattingConversionServiceFactoryBean 了。 idea 工程上传的图片，页面显示不出来1）idea里面配置static/image/upload文件资源 2）idea中tomcat发布项目的默认路径是项目所在地里的target目录里面，修改工程输出到Tomcat下]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>开发经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式架构 - 协调服务器 Zookeeper]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1%E5%99%A8-Zookeeper.html</url>
    <content type="text"><![CDATA[什么是 ZookeeperZookeeper 是一个分布式开源框架，提供了协调分布式应用的基本服务，它向外部应用暴露一组通用服务——分布式同步（Distributed Synchronization）、命名服务（Naming Service）、集群维护（Group Maintenance）等，简化分布式应用协调及其管理的难度，提供高性能的分布式服务。ZooKeeper本身可以以单机模式安装运行，不过它的长处在于通过分布式 ZooKeeper 集群（一个 Leader，多个 Follower），基于一定的策略来保证 ZooKeeper 集群的稳定性和可用性，从而实现分布式应用的可靠性。 Zookeeper 是为别的分布式程序服务的 Zookeeper 本身就是一个分布式程序（只要有半数以上节点存活，zk 就能正常服务） Zookeeper 所提供的服务涵盖：主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统&gt; 一名称服务等 虽然说可以提供各种服务，但是 zookeeper 在底层其实只提供了两个功能：管理(存储，读取)用户程序提交的数据（类似 namenode 中存放的 metadata）； 并为用户程序提供数据节点监听服务； Zookeeper 集群机制Zookeeper 集群的角色： Leader 和 follower 只要集群中有半数以上节点存活，集群就能提供服务 Zookeeper 特性 Zookeeper：一个 leader，多个 follower 组成的集群 全局数据一致：每个 server 保存一份相同的数据副本，client 无论连接到哪个 server，数据都是一致的 分布式读写，更新请求转发，由 leader 实施 更新请求顺序进行，来自同一个 client 的更新请求按其发送顺序依次执行 数据更新原子性，一次数据更新要么成功，要么失败 实时性，在一定时间范围内，client 能读到最新数据 Zookeeper 数据结构ZooKeeper 提供的名称空间非常类似于标准文件系统。名称是由斜线（/）分隔的一系列路径元素。ZooKeeper 名称空间中的每个节点都由一个路径标识。 树是由节点所组成，zookeeper 的数据存储也同样是基于节点，这个节点叫做 Znode.但是，不同于树的节点，Znode 的引用方式是路径引用，类似于文件路径：/app1/p_1。 这样的层级结构，让每一个Znode节点拥有唯一的路径，就像命名空间一样对不同信息作出清晰的隔离。 ZooKeeper 中节点和临时节点ZooKeeper 的节点是通过像树一样的结构来进行维护的，并且每一个节点通过路径来标示以及访问。除此之外，每一个节点还拥有自身的一些信息，包括：数据、数据长度、创建时间、修改时间等等。从这样一类既含有数据，又作为路径表标示的节点的特点中，可以看出，ZooKeeper 的节点既可以被看做是一个文件，又可以被看做是一个目录，它同时具有二者的特点。 具体地说，Znode 维护着数据、ACL（access control list，访问控制列表）、时间戳等交换版本号等数据结构，它通过对这些数据的管理来让缓存生效并且令协调更新。每当 Znode 中的数据更新后它所维护的版本号将增加，这非常类似于数据库中计数器时间戳的操作方式。 另外 Znode 还具有原子性操作的特点：命名空间中，每一个 Znode 的数据将被原子地读写。读操作将读取与 Znode 相关的所有数据，写操作将替换掉所有的数据。除此之外，每一个节点都有一个访问控制列表，这个访问控制列表规定了用户操作的权限。 ZooKeeper 中同样存在临时节点。这些节点与 session 同时存在，当 session 生命周期结束，这些临时节点也将被删除。临时节点在某些场合也发挥着非常重要的作用。 Zookeeper 应用场景 数据发布与订阅（配置中心） 负载均衡 命名服务（Naming Service） 分布式通知/协调 集群管理与 Master 选举 分布式锁 分布式事务 更多教程可以参考官方文档，大家可以去Apache ZooKeeper 官方文档。 持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>架构</tag>
        <tag>协调服务器</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式架构 - 微服务框架 Dubbo]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6-Dubbo.html</url>
    <content type="text"><![CDATA[Dubbo 的背景随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。 单一应用架构：当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 此时，用于简化增删改查工作量的数据访问框架（ORM）是关键。 垂直应用架构：当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 此时，用于加速前端页面开发的Web框架（MVC）是关键。 分布式服务架构：当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 此时，用于提高业务复用及整合的分布式服务框架（RPC）是关键。 流动计算架构：当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键。 什么是 DubboDubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，SOA 服务治理方案。 简单的说，dubbo 就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有 dubbo 这样的分布式服务框架的需求。 并且本质上是个服务调用，说白了就是个远程服务调用的分布式框架（告别 Web Service 模式中的 wsdl,以服务者与消费者的方式在 dubbo 上注册）。 其核心部分包含: 1.远程通讯: 提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。 2.集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 3.自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 Dubbo能做什么具体能做什么： 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 总结：Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 Spring 的 Schema 扩展进行加载。 Dubbo 架构Dubbo 已进入 Apache 孵化器。Apache Dubbo官网地址 节点角色说明： Provider: 暴露服务的服务提供方。 Consumer: 调用远程服务的服务消费方。 Registry: 服务注册与发现的注册中心。 Monitor: 统计服务的调用次调和调用时间的监控中心。 Container: 服务运行容器。 调用关系说明： 0.服务容器负责启动，加载，运行服务提供者。 1.服务提供者在启动时，向注册中心注册自己提供的服务。 2.服务消费者在启动时，向注册中心订阅自己所需的服务。 3.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 更多详细教程可参考官方文档 持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>架构</tag>
        <tag>微服务</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构 - Spring Cloud]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-Spring-Cloud.html</url>
    <content type="text"><![CDATA[什么是微服务Spring Cloud 是 Spring 旗下的项目之一，Spring Cloud 官网地址：http://projects.spring.io/spring-cloud/ Spring 最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。Spring Cloud 也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： Spring Cloud Netflix Eureka：注册中心 Zuul：服务网关 Ribbon：负载均衡 Feign：服务调用 Hystix：熔断器 Spring Cloud Config：由 git 存储库支持的集中式外部配置管理。 Spring Cloud Bus：用于将服务和服务实例与分布式消息相连接的事件总线，在集群中传播状态变化（例如配置更改事件）。 更多教程可以参考官方文档，大家可以去Spring Cloud 官方文档中学习。 持续更新中…]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构 - Spring Boot]]></title>
    <url>%2F2018%2F06%2F14%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-Spring-Boot.html</url>
    <content type="text"><![CDATA[什么是 Spring BootSpring Boot 是 Spring 项目中的一个子工程，与我们所熟知的 Spring-framework 同属于 spring 的产品。 我们可以看到下面的一段介绍： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把 Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的 spring 项目，并且尽可能的减少一切 xml 配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 为什么要学习 Spring Bootjava 一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能 Python 程序员已经把功能写好了，究其原因注意是两点： 复杂的配置 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 我们可以使用 SpringBoot 创建 java 应用，并使用java –jar启动它，就能得到一个生产级别的 web 工程。 Spring Boot 的优点Spring Boot 主要目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验。 开箱即用（启动器 starter-其实就是 SpringBoot 提供的一个 jar 包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等。 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到Spring boot 官网查看。 快速入门创建工程创建 maven 名为 springboot-demo 的 Spring Boot 工程。 添加依赖123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.github.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写启动类123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 编写 controller12345678@RestControllerpublic class HelloController &#123; @GetMapping("hello") public String hello()&#123; return "hello, spring boot!"; &#125;&#125; 更多技能 Spring boot 整合 mybatis Spring boot 整合 jpa Spring boot 整合 redis Spring boot 整合 MQ Spring boot 整合 … 官方文档是最好的教程网站Spring boot 官网，大家可以到Spring boot 官网 学习更多知识。s]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统 - 内存数据库 Redis]]></title>
    <url>%2F2018%2F05%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-Redis.html</url>
    <content type="text"><![CDATA[什么是 NoSqlNoSQL，即 Not-Only SQL，泛指非关系型的数据库。它是为了解决高并发、高可用、高可扩展、大数据存储问题而产生的数据库解决方案。NoSQL 可以作为关系型数据库的良好补充，但是不能替代关系型数据库。 NoSql 数据库分类键值(Key-Value)存储数据库相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 列存储数据库相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库相关产品：CouchDB、MongoDB典型应用：Web 应用（与 Key-Value 类似，Value 是结构化的）数据模型： 一系列键值对优势：数据结构要求不严格劣势：查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 Redis 是什么Redis 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止 Redis 支持的键值数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型 Redis 的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等）。 分布式集群架构中的 session 分离。 聊天室的在线好友列表。 任务队列。（秒杀、抢购、12306 等等） 应用排行榜。 网站访问统计。 数据过期处理（可以精确到毫秒） 持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>系统</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式架构 - Nginx]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-Nginx.html</url>
    <content type="text"><![CDATA[什么是 NginxNginx 是俄罗斯人编写的一款高性能的 HTTP 和反向代理服务器。 在高连接并发的情况下，它能够支持高达 50000 个并发连接数的响应，但是内存、CPU 等系统资源消耗却很低，运行很稳定。 Nginx 的优势选择 Nginx 的理由也很简单： 第一，它可以支持5W高并发连接； 第二，内存消耗少； 第三，成本低，如果采用 F5、NetScaler 等硬件负载均衡设备的话，需要大几十万。而 Nginx 是开源的，可以免费使用并且能用于商业用途。 分布式架构中的作用最常用的有三项： 路由功能（与微服务对应）：域名/路径，进行路由选择后台服务器； 负载功能（与高并发高可用对应）：对后台服务器集群进行负载； 静态服务器（比 Tomcat 性能高很多）：在 mvvm 模式中，充当文件读取职责。 总结：实际使用中，这三项功用，会混合使用。比如先分离动静，再路由服务，再负载机器。 代理正向代理：客户端自己请求出现困难。客户请了一个代理，来代自己做事，就叫代理。比如代理律师，代购，政府机关办事的代理人等等。反向代理：服务端推出的一个代理招牌。 Nginx 安装源码编译方式一般系统中已经装了了 make 和 g++，无须再装。1234# 安装 makeyum -y install autoconf automake make# 安装 g++yum -y install gcc gcc-c++ 安装nginx依赖的库123456# 安装 pcre yum -y install pcre pcre-devel# 安装 zlib yum -y install zlib zlib-devel# 安装 openssl yum install -y openssl openssl-devel Nginx 官方下载地址 安装 Nginx 123456789# 下载 Nginxwget http://nginx.org/download/nginx-1.16.0.tar.gz# 解压 Nginxtar -zxvf nginx-1.16.0.tar.gzcd nginx-1.16.0# 安装 HTTPS 模块./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module# 安装make &amp;&amp; make install --prefix 指定安装目录--with-http_ssl_module 安装 HTTPS 模块make 编译make install 安装 yum 方式Linux 系统下：123# yum扩展源yum install epel-release -yyum install nginx -y 目录结构 Conf：配置文件 Html：网页文件 Logs：日志文件 Sbin：二进制程序 启停命令./nginx -c nginx.conf的文件。如果不指定，默认为 NGINX_HOME/conf/nginx.conf./nginx -s stop 停止./nginx -s quit 退出./nginx -s reload 重新加载 nginx.conf 发送信号的方式kill -QUIT 进程号 安全停止kill -TERM 进程号 立即停止 配置文件Nginx 全局属性的配置12345678910111213#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125; user：主模块命令， 指定Nginx的worker进程运行用户以及用户组，默认由 nobody 账号运行。worker_processes: 指定 Nginx 要开启的进程数。error_log：用来定义全局错设日志文件的路径和日志名称。日志输出级别有 debug，info，notice，warn，error，crit 可供选择，其中 debug 输出日志最为详细，而 crit（严重）输出日志最少。默认是 error。 pid: 用来指定进程 id 的存储文件位置。event：设定 nginx 的工作模式及连接数上限，其中参数 use 用来指定 nginx 的工作模式（这里是 epoll，epoll 是多路复用 IO(I/O Multiplexing)中的一种方式）,nginx 支持的工作模式有 select ,poll,kqueue,epoll,rtsig,/dev/poll。其中 select 和 poll 都是标准的工作模式，kqueue 和 epoll 是高效的工作模式，对于 linux 系统，epoll 是首选。 worker_connection：是设置 nginx 每个进程最大的连接数，默认是1024，所以nginx最大的连接数 max_client=worker_processes * worker_connections。进程最大连接数受到系统最大打开文件数的限制，需要设置 ulimit。 http 服务器相关属性的配置1234567891011121314151617http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; include：主模块命令，对配置文件所包含文件的设定，减少主配置文件的复杂度，相当于把部分设置放在别的地方，然后在包含进来，保持主配置文件的简洁。default_type：默认文件类型，当文件类型未定义时候就使用这类设置的。log_format：设定日志格式。sendfile：开启高效文件传输模式（zero copy 方式），避免内核缓冲区数据和用户缓冲区数据之间的拷贝。tcp_nopush：开启 TCP_NOPUSH 套接字（sendfile 开启时有用）keepalive_timeout：客户端连接超时时间gzip：设置是否开启 gzip 模块 server 段虚拟主机的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125;&#125; listen：虚拟主机的服务端口server_name：用来指定ip或者域名，多个域名用逗号分开charset：设置字符编码location /：默认请求 root：虚拟主机的网页根目录 index：默认访问首页文件error_page：定义错误提示页面location ~ .php$：PHP 脚本请求全部转发到 FastCGI 处理.，使用FastCGI默认配置。location ~ /.ht：禁止访问 .htxxx 文件 Nginx 日志描述通过访问日志，你可以得到用户地域来源、跳转来源、使用终端、某个URL访问量等相关信息；通过错误日志，你可以得到系统某个服务或server的性能瓶颈等。 因此，将日志好好利用，你可以得到很多有价值的信息。 日志格式打开nginx.conf配置文件：vi /usr/local/nginx/conf/nginx.conf日志部分内容：#access_log logs/access.log main; 日志生成的到 Nginx 根目录 logs/access.log 文件，默认使用 main 日志格式，也可以自定义格式。 参数明细表 参数 说明 $remote_addr 客户端的ip地址(代理服务器，显示代理服务ip) $remote_user 用于记录远程客户端的用户名称（一般为“-”） $time_local 用于记录访问时间和时区 $request 用于记录请求的url以及请求方法 $status 响应状态码，例如：200成功、404页面找不到等。 $body_bytes_sent 给客户端发送的文件主体内容字节数 $http_user_agent 用户所使用的代理（一般为浏览器） $http_x_forwarded_for 可以记录客户端IP，通过代理服务器来记录客户端的ip地址 $http_referer 可以记录用户是从哪个链接访问过来的 查看日志命令 tail -f /usr/local/nginx/logs/access.log持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>架构</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
</search>
