<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot自定义favicon.ico]]></title>
    <url>%2F2018%2F04%2F12%2FSpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89favicon-ico.html</url>
    <content type="text"><![CDATA[默认的FaviconSpring Boot提供了一个默认的Favicon，每次访问应用的时候都能看到。 关闭Favicon我们可以在application.properties中设置关闭Favicon，默认为开启。 1spring.mvc.favicon.enable=false 或在application.yml中设置关闭Favicon 1234spring: mvc: favicon: enabled: false 设置自己的Favicon若需要设置自己的Favicon，则只需将自己的favicon.ico文件放置在类路径根目录、类路径META-INF/resources/下、类路径resources/下、类路径static/下或类路径public/下。 这里将favicon.ico放置在src/main/resources/static下。 源码分析application.properties1spring.mvc.favicon.enabled=false IndexController .java123456789@Controllerpublic class IndexController &#123; @RequestMapping(value = "/index") public String index(Model model) &#123; model.addAttribute("name","SpringBootFavicon"); return "index"; &#125;&#125; IndexRestController .java12345678@RestControllerpublic class IndexRestController &#123; @RequestMapping(value = "/indexRest") public String index() &#123; return "indexRest"; &#125;&#125; RunApplication .java1234567@SpringBootApplicationpublic class RunApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RunApplication.class, args) ; &#125;&#125; 运行RunApplication,java 效果图访问Rest请求 访问页面 访问错误请求 源码下载SpringBoot自定义favicon.ico(含源码) SpringBoot 入门+实战系列源码)]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot进阶之访问数据库]]></title>
    <url>%2F2018%2F04%2F11%2FSpringBoot%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
    <content type="text"><![CDATA[本文介绍在Spring Boot基础下配置数据源和通过JdbcTemplate编写数据访问的示例。 简单介绍一下@Controller：修饰class，用来创建处理http请求的对象@RestController：Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。@RequestMapping：配置url映射 数据源配置 首先，为了连接数据库需要引入jdbc支持，在pom.xml中引入如下配置：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 以MySQL数据库为例，先引入MySQL连接的依赖包，在pom.xml中加入： 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt;&lt;/dependency&gt; 配置数据源信息在application.yml配置数据源信息123456spring: datasource: url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8 username: root password: root driver-class-name: com.mysql.jdbc.Driver 使用JdbcTemplate操作数据库编写实体类Student.java 12345678910111213141516171819202122232425262728293031323334package com.javazhan.domain;public class Student &#123; private int id ; private String name ; private int age ; private String address ; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; 编写StudentService.java 12345678910111213141516171819202122232425262728293031323334353637package com.javazhan.service;import java.util.List;import com.javazhan.domain.Student;public interface StudentService &#123; /** * 新增一个学生 * @param student */ void create(Student student) ; /** * 根据id删除一个学生 * @param id */ void deleteById(int id) ; /** * 查出所有学生 * @return */ List&lt;Student&gt; getAllStudent() ; /** * 根据id查出学生 * @return */ Student getStudentById(int id) ; /** * 根据Id更新一个学生 */ void updateStudentById(Student student) ;&#125; 编写实现类StudentServiceImpl.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.javazhan.service.impl;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.ResultSetExtractor;import org.springframework.jdbc.core.RowMapper;import org.springframework.stereotype.Service;import com.javazhan.domain.Student;import com.javazhan.service.StudentService;@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private JdbcTemplate jdbcTemplate ; @Override public void create(Student student) &#123; // TODO Auto-generated method stub jdbcTemplate.update("insert into student(name, age, address) value(?,?,?)", student.getName(), student.getAge(), student.getAddress()) ; &#125; @Override public void deleteById(int id) &#123; // TODO Auto-generated method stub jdbcTemplate.update("delete from student where id = ?", id) ; &#125; @Override public List&lt;Student&gt; getAllStudent() &#123; // TODO Auto-generated method stub return jdbcTemplate.query("select * from student", new RowMapper() &#123; @Override public Object mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Student student = new Student(); student.setId(rs.getInt("id")); student.setName(rs.getString("name")); student.setAge(rs.getInt("age")); student.setAddress(rs.getString("address")); return student; &#125; &#125;) ; &#125; @Override public Student getStudentById(int id) &#123; // TODO Auto-generated method stub return (Student) jdbcTemplate.query("select * from student where id=?", new ResultSetExtractor() &#123; @Override public Student extractData(ResultSet rs) throws SQLException &#123; while (rs.next()) &#123; Student student = new Student(); student.setId(rs.getInt("id")); student.setName(rs.getString("name")); student.setAge(rs.getInt("age")); student.setAddress(rs.getString("address")); return student ; &#125; return null ; &#125; &#125;, id); &#125; @Override public void updateStudentById(Student student) &#123; // TODO Auto-generated method stub jdbcTemplate.update("update student set name=?, age=?, address=? where id =?", student.getName(), student.getAge(), student.getAddress(),student.getId()) ; &#125; &#125; 我们尝试使用Spring MVC来实现一组对Student对象操作的RESTful API，配合注释详细说明在Spring MVC中如何映射HTTP请求、如何传参、如何编写单元测试。| 请求类型 | URL | 功能说明 || ————- |:————-| —–|| GET | /student | 查询所有学生 || POST | /student | 新增一个学生 || GET | /student/id | 根据id查询一个学生 || PUT | /student/id | 根据id更新一个学生 || DELETE | /student/id | 根据id删除一个学生 | 编写StudentRestController .java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.javazhan.web.rest;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import com.javazhan.domain.Student;import com.javazhan.service.StudentService;@RestController@RequestMapping(value="student")public class StudentRestController &#123; @Autowired private StudentService stuService ; /** * 查出所有学生 * @return */ @RequestMapping(value="/", method=RequestMethod.GET) public List&lt;Student&gt; getAllStudent() &#123; return stuService.getAllStudent() ; &#125; /** * 根据id查出学生 * @return */ @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.GET) public Student getStudentById(@PathVariable Integer id) &#123; return stuService.getStudentById(id) ; &#125; /** * 根据id删除学生 * @return */ @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.DELETE) public String deleteById(@PathVariable Integer id) &#123; stuService.deleteById(id) ; return "success" ; &#125; /** * 新增一个学生 * @return */ @RequestMapping(value="/", method=RequestMethod.POST) public String create(@ModelAttribute Student student) &#123; stuService.create(student) ; return "success" ; &#125; /** * 根据Id更新一个学生 * @return */ @RequestMapping(value="/", method=RequestMethod.PUT) public String updateStudentById(@ModelAttribute Student student) &#123; stuService.updateStudentById(student) ; return "success" ; &#125;&#125; 编写测试RestTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.java.test;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.RequestBuilder;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;import com.javazhan.RunApplication;@RunWith(SpringRunner.class)@SpringBootTest(classes=RunApplication.class)public class RestTest &#123; @Autowired private WebApplicationContext context; // mock api 模拟http请求 private MockMvc mvc; @Before public void setUp() throws Exception &#123; //集成Web环境测试（此种方式并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器） mvc = MockMvcBuilders.webAppContextSetup(context).build(); &#125; @Test public void testUserController() throws Exception &#123; RequestBuilder request = null ; MvcResult mvcResult = null ; int status = 500 ; // 新增学生 request = post("/student/").param("name", "李四") .param("age", "20") .param("address", "哈尔滨") ; mvcResult = mvc.perform(request).andReturn() ; status = mvcResult.getResponse().getStatus() ; if(status==200) &#123; String content = mvcResult.getResponse().getContentAsString() ; System.out.println("新增学生："+content) ; &#125; // 查出所有学生 request = get("/student/") ; mvcResult = mvc.perform(request).andReturn() ; status = mvcResult.getResponse().getStatus() ; if(status==200) &#123; String content = mvcResult.getResponse().getContentAsString() ; System.out.println("查出所有学生："+content); &#125; // 根据Id查询学生 request = get("/student/1") ; mvcResult = mvc.perform(request).andReturn() ; status = mvcResult.getResponse().getStatus() ; if(status==200) &#123; String content = mvcResult.getResponse().getContentAsString() ; System.out.println("根据Id查询学生："+content) ; &#125; // 根据Id更新一个学生 request = put("/student/").param("id", "5") .param("name", "李四5") .param("age", "25") .param("address", "哈尔滨5") ; mvcResult = mvc.perform(request).andReturn() ; status = mvcResult.getResponse().getStatus() ; if(status==200) &#123; String content = mvcResult.getResponse().getContentAsString() ; System.out.println("根据Id更新一个学生："+content) ; &#125; // 根据id删除一个学生 request = delete("/student/6") ; mvcResult = mvc.perform(request).andReturn() ; status = mvcResult.getResponse().getStatus() ; if(status==200) &#123; String content = mvcResult.getResponse().getContentAsString() ; System.out.println("根据id删除一个学生："+content) ; &#125; &#125;&#125; 编写RunApplication.java123456789101112package com.javazhan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class RunApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RunApplication.class, args) ; &#125;&#125; 源码下载SpringBoot进阶之访问数据库（含源码）]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JdbcTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot进阶之模板引擎]]></title>
    <url>%2F2018%2F04%2F11%2FSpringBoot%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.html</url>
    <content type="text"><![CDATA[在动态HTML实现上Spring Boot依然可以完美胜任，并且提供了多种模板引擎的默认配置支持，所以在推荐的模板引擎下，我们可以很快的上手开发动态网站。 模板引擎种类Spring Boot提供了默认配置的模板引擎主要有以下几种： Thymeleaf FreeMarker Velocity Groovy Mustache 当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。 ThymeleafThymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。 在Spring Boot中使用Thymeleaf，只需要引入下面依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 案例-遍历所有学生信息 效果图： 工程结构 root package结构：com.example.myproject 应用主类Application.java置于rootpackage下，通常我们会在应用主类中做一些框架配置扫描等配置，我们放在root package下可以帮助程序减少手工配置来加载到我们希望被Spring加载的内容 实体（Entity）与数据访问层（Repository）置于com.example.myproject.domain包下 逻辑层（Service）置于com.example.myproject.service包下 Web层（web）置于com.example.myproject.web包下 实体类 Student .java1234567891011121314151617181920212223242526272829303132package com.javazhan.domain;public class Student &#123; private int id ; private String name ; private int age ; private String address ; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; web层 StudentController .java1234567891011121314151617181920212223242526272829package com.javazhan.controller;import java.util.ArrayList;import java.util.List;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import com.javazhan.domain.Student;@Controllerpublic class StudentController &#123; @RequestMapping("/getStudentList") public String getStudentList(ModelMap map) &#123; List&lt;Student&gt; list = new ArrayList&lt;Student&gt;() ; for(int i=0; i&lt;=5; i++) &#123; Student st = new Student() ; st.setId(i+1) ; st.setName("章三"+(i+1)) ; st.setAge(20+i) ; st.setAddress("北京故宫门牌号20"+i) ; list.add(st) ; &#125; map.addAttribute("list", list); return "index" ; &#125;&#125; 启动类 RunApplication.java123456789101112package com.javazhan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class RunApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RunApplication.class, args) ; &#125;&#125; 页面 index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org" lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt;&lt;/meta&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;/meta&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;/meta&gt; &lt;title&gt;学生信息&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"&gt;&lt;/link&gt; &lt;link rel="stylesheet" type="text/css" href="/css/style.css"&gt;&lt;/link&gt; &lt;link rel="stylesheet" type="text/css" href="/css/font-awesome.min.css"&gt;&lt;/link&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 内容 --&gt;&lt;div class="container"&gt; &lt;br&gt;&lt;/br&gt; &lt;div class="panel panel-warning"&gt; &lt;div class="panel-heading"&gt;&lt;span class="text-size"&gt;&lt;i class="icon-link"&gt;&lt;/i&gt; 学生所有信息&lt;/span&gt;&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each="list : $&#123;list&#125;"&gt; &lt;td th:text="$&#123;list.id&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;list.name&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;list.age&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;list.address&#125;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 内容 --&gt;&lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt;&lt;script type="text/javascript" src="/js/jquery-1.11.2.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 更多使用技巧请查看Thymeleaf官网文档 若想修改默认参数配置参考如下，如缓存，编码，修改默认的模板路径等。 123456789101112131415161718# Enable template caching.spring.thymeleaf.cache=true # Check that the templates location exists.spring.thymeleaf.check-template-location=true # Content-Type value.spring.thymeleaf.content-type=text/html # Enable MVC Thymeleaf view resolution.spring.thymeleaf.enabled=true # Template encoding.spring.thymeleaf.encoding=UTF-8 # Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.excluded-view-names= # Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.mode=HTML5 # Prefix that gets prepended to view names when building a URL.spring.thymeleaf.prefix=classpath:/templates/ # Suffix that gets appended to view names when building a URL.spring.thymeleaf.suffix=.html spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved. 源码下载SpringBoot进阶之模板引擎源码]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot入门之Web开发]]></title>
    <url>%2F2018%2F04%2F11%2FSpringBoot%E5%85%A5%E9%97%A8%E4%B9%8BWeb%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[静态资源目录Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：1234/static/public/resources/META-INF/resources 配置文件Spring Boot项目使用一个全局的配置文件application.properties或者是application.yml，在resources目录下或者类路径下的/config下，一般我们放到resources下。 修改tomcat端口配置 1server.port=8888 修改Spring MVC拦截路径规则默认Spring MVC拦截路径规则是/，如果要修改成*.html的话，可以在全局配置文件中进行如下设置： 1server.servlet-path=*.html 视图解析器配置一样的，Spring Boot也可以通过全局配置文件对视图解析器进行配置： 12spring.mvc.view.prefix=/WEB-INF/views/spring.mvc.view.suffix=.jsp 日志输出Spring Boot对各种日志框架都做了支持，我们可以通过配置来修改默认的日志的配置： 12#设置日志级别logging.level.org.springframework=DEBUG application.yml properties与yml文件在形式上有所差别，yml文件的书写方式比较简洁，类似eclipse中package的flag呈现方式（而properties文件则像Hierarchical方式）。如上面properties文件中的属性配置使用yml文件来写： 1234567891011121314server: port: 8888 context-path: /spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsplogging: level: org: springframework: debug 注：推荐使用yml文件在书写，需要注意一个地方：冒号与值中间是存在空格的！ Spring Boot的全局配置很强大，同时它可以配置的属性也很多，以上只列出几个常用的属性配置，如需查看完整的全局属性配置，请到spring-boot官方配置文档查看。 源码下载SpringBoot入门之Web开发源码]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot入门之HelloWorld]]></title>
    <url>%2F2018%2F04%2F11%2FSpringBoot%E5%85%A5%E9%97%A8%E4%B9%8BHelloWorld.html</url>
    <content type="text"><![CDATA[SpringBoot是什么？Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 SpringBoot优点？ 快速构建项目 对主流开发框架的无配置集成 项目可独立运行，无须外部依赖Servlet容器（Spring Boot默认自带了一个Tomcat） 提供运行时的应用监控 极大地提高了开发、部署效率 提供一系列大型企业级项目的功能性特性 那就开始我们的HelloWorld只需三步就完成我们的HelloWorld 第一步，我们新建一个Maven项目。给项目添加架包依赖，修改pom.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.javazhan&lt;/groupId&gt; &lt;artifactId&gt;sb01&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 第二步，新建一个类HelloWorldController .java 12345678910111213package com.javazhan.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloWorldController &#123; @RequestMapping("/helloworld") public String helloworld() &#123; return "HelloWorld!" ; &#125;&#125; 新建一个启动类RunApplication.java 1234567891011package com.javazhan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class RunApplication&#123; public static void main( String[] args )&#123; SpringApplication.run(RunApplication.class, args) ; &#125;&#125; 第三步，运行RunApplication.java，在浏览器输入地址http://localhost:8080/helloworld查看结果 知识点一般Spring Boot的Web应用都有一个xxxApplication类，并使用@SpringBootApplication注解标记，作为该web应用的加载入口。此外，还需要在main方法中(可以是任意一个类)使用SpringApplication.run(xxxApplication.class, args)来启动该web应用 源码下载SpringBoot入门之HelloWorld源码]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列1 工厂模式]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%971-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 使用场景 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 五种工厂模式1）简单工厂（静态）案例：生产车辆 抽象一个汽车基类，或者是接口123456public abstract class CarPrototype &#123; /** * 生产汽车 */ public abstract void produce();&#125; 生产奥迪汽车（具体的产品类） 123456789public class AodeCar extends CarPrototype &#123; @Override public void produce() &#123; // TODO Auto-generated method stub System.out.println("生产一辆奥迪汽车。。。。。。。。。。。。"); &#125;&#125; 生产宝马汽车（具体的产品类） 123456789public class BaomaCar extends CarPrototype &#123; @Override public void produce() &#123; // TODO Auto-generated method stub System.out.println("生产一辆宝马汽车。。。。。。。。。。。。"); &#125;&#125; 生产红旗汽车（具体的产品类） 123456789public class HongqiCar extends CarPrototype &#123; @Override public void produce() &#123; // TODO Auto-generated method stub System.out.println("生产一辆红旗汽车。。。。。。。。。。。。"); &#125;&#125; 汽车工厂（简单工厂类） 12345678910111213141516public class SimpleCarFactory &#123; public static CarPrototype createCar(String type) &#123; switch(type) &#123; case "baoma": return new BaomaCar(); case "aode": return new AodeCar(); case "hongqi": return new HongqiCar(); default: throw new BaseException("工厂类无法匹配汽车，没法生产。。。。。"); &#125; &#125;&#125; 测试生产汽车 123456public class TestCarFactory &#123; public static void main(String[] args) &#123; CarPrototype carPrototype = new SimpleCarFactory().createCar("baoma"); carPrototype.produce(); &#125;&#125; 结果 1生产一辆宝马汽车。。。。。。。。。。。。 特点1 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。2 create()方法通常是静态的，所以也称之为静态工厂。缺点1 扩展性差（我想增加一种汽车，除了新增一个汽车产品类，还需要修改工厂类方法）2 不同的产品需要不同额外参数的时候 不支持。 2）简单工厂（反射）利用反射Class.forName(clz.getName()).newInstance()实现的简单工厂 12345678910111213public class ReflectionCarFactory &#123; public static &lt;T extends CarPrototype&gt; T createCar(Class&lt;T&gt; prototype) &#123; T result = null; try &#123; result = (T)Class.forName(prototype.getName()).newInstance(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return result; &#125;&#125; 测试简单工厂（反射） 123456789101112public class TestCarFactory &#123; public static void main(String[] args) &#123; // 简单工厂（静态） /*CarPrototype carPrototype = new SimpleCarFactory().createCar("baoma"); carPrototype.produce();*/ // 简单工厂（反射） CarPrototype carPrototype = ReflectionCarFactory.createCar(AodeCar.class); carPrototype.produce(); &#125;&#125; 结果 1生产一辆奥迪汽车。。。。。。。。。。。。 特点1 它也是一个具体的类，非接口 抽象类。但它的create()方法，是利用反射机制生成对象返回，好处是增加一种产品时，不需要修改create()的代码。缺点这种写法粗看牛逼，细想之下，不谈reflection的效率还有以下问题：1 个人觉得不好，因为Class.forName(clz.getName()).newInstance()调用的是无参构造函数生成对象，它和new Object()是一样的性质，而工厂方法应该用于复杂对象的初始化 ，当需要调用有参的构造函数时便无能为力了，这样像为了工厂而工厂。2 不同的产品需要不同额外参数的时候 不支持。 3）多方法工厂（常用）不同的产品需要不同额外参数的时候 不支持。而且如果使用时传递的type、Class出错，将不能得到正确的对象，容错率不高。而多方法的工厂模式为不同产品，提供不同的生产方法，使用时 需要哪种产品就调用该种产品的方法，使用方便、容错率高。 工厂如下 1234567891011121314151617181920212223public class ManyWayCarFactory &#123; /** * 生产奥迪汽车 * @return */ public static CarPrototype createAodeCar() &#123; return new AodeCar(); &#125; /** * 生产宝马汽车 * @return */ public static CarPrototype createBaomaCar() &#123; return new BaomaCar(); &#125; /** * 生产红旗汽车 * @return */ public static CarPrototype createHongqiCar() &#123; return new HongqiCar(); &#125;&#125; 测试多方法工厂（常用） 12345678910111213141516public class TestCarFactory &#123; public static void main(String[] args) &#123; // 简单工厂（静态） /*CarPrototype carPrototype = new SimpleCarFactory().createCar("baoma"); carPrototype.produce();*/ // 简单工厂（反射） /*CarPrototype carPrototype = ReflectionCarFactory.createCar(AodeCar.class); carPrototype.produce();*/ // 多方法静态工厂(模仿Executor类） CarPrototype carPrototype = new ManyWayCarFactory().createHongqiCar(); carPrototype.produce(); &#125;&#125; 结果 1生产一辆红旗汽车。。。。。。。。。。。。 4）普通工厂普通工厂就是把简单工厂中具体的工厂类，划分成两层：抽象工厂层+具体的工厂子类层。（一般-&gt;特殊） 汽车工厂（抽象工厂类），作用就是生产汽车： 123public abstract class CarFactory &#123; public abstract CarPrototype create();&#125; 生产奥迪工厂（具体工厂子类） 12345678public class AodeFactory extends CarFactory &#123; public CarPrototype create() &#123; // TODO Auto-generated method stub return new AodeCar(); &#125; &#125; 生产宝马工厂（具体工厂子类） 12345678public class BaomaFactory extends CarFactory &#123; public CarPrototype create() &#123; // TODO Auto-generated method stub return new BaomaCar(); &#125; &#125; 生产红旗工厂（具体工厂子类） 12345678public class HongqiFactory extends CarFactory &#123; public CarPrototype create() &#123; // TODO Auto-generated method stub return new HongqiCar(); &#125; &#125; 测试普通工厂1234567891011121314151617181920public class TestCarFactory &#123; public static void main(String[] args) &#123; // 简单工厂（静态） /*CarPrototype carPrototype = new SimpleCarFactory().createCar("baoma"); carPrototype.produce();*/ // 简单工厂（反射） /*CarPrototype carPrototype = ReflectionCarFactory.createCar(AodeCar.class); carPrototype.produce();*/ // 多方法静态工厂(模仿Executor类） /*CarPrototype carPrototype = new ManyWayCarFactory().createHongqiCar(); carPrototype.produce();*/ // 普通工厂 CarPrototype carPrototype = new BaomaFactory().create(); carPrototype.produce(); &#125;&#125; 结果 1生产一辆宝马汽车。。。。。。。。。。。。 普通工厂与简单工厂模式的区别：可以看出，普通工厂模式特点：不仅仅做出来的产品要抽象， 工厂也应该需要抽象。工厂方法使一个产品类的实例化延迟到其具体工厂子类。工厂方法的好处就是更拥抱变化。当需求变化，只需要增删相应的类，不需要修改已有的类。而简单工厂需要修改工厂类的create()方法，多方法静态工厂模式需要增加一个静态方法。缺点：引入抽象工厂层后，每次新增一个具体产品类，也要同时新增一个具体工厂类，所以我更青睐 多方法静态工厂。 5）抽象工厂以上介绍的工厂都是单产品系的。抽象工厂是多产品系 （貌似也有产品家族的说法）。举个例子来说，每个店(工厂)不仅仅生产汽车，还生产零件。 生产零件，零件是产品，先抽象一个产品类，零件：123456public abstract class ComponentsPrototype &#123; /** * 生产零件 */ public abstract void produce();&#125; 生产车门123456789public class CarDoorComponents extends ComponentsPrototype &#123; @Override public void produce() &#123; // TODO Auto-generated method stub System.out.println("生产车门-------------"); &#125;&#125; 生产发动机123456789public class EngineComponents extends ComponentsPrototype &#123; @Override public void produce() &#123; // TODO Auto-generated method stub System.out.println("生产发动机-------------"); &#125;&#125; 抽象汽车工厂（抽象工厂类）123456789101112public abstract class AbstractCarFactory &#123; /** * 生产汽车 * @return */ public abstract CarPrototype createCar(); /** * 生产零件 * @return */ public abstract ComponentsPrototype createComponents();&#125; 测试抽象工厂 1234567891011121314151617181920212223242526public class TestCarFactory &#123; public static void main(String[] args) &#123; // 简单工厂（静态） /*CarPrototype carPrototype = new SimpleCarFactory().createCar("baoma"); carPrototype.produce();*/ // 简单工厂（反射） /*CarPrototype carPrototype = ReflectionCarFactory.createCar(AodeCar.class); carPrototype.produce();*/ // 多方法静态工厂(模仿Executor类） /*CarPrototype carPrototype = new ManyWayCarFactory().createHongqiCar(); carPrototype.produce();*/ // 普通工厂 /*CarPrototype carPrototype = new BaomaFactory().create(); carPrototype.produce();*/ // 抽象工厂 CarPrototype carPrototype = new ChinaCarFactory().createCar(); carPrototype.produce(); ComponentsPrototype componentsPrototype = new ChinaCarFactory().createComponents(); componentsPrototype.produce(); &#125;&#125; 结果12生产一辆宝马汽车。。。。。。。。。。。。生产发动机-------------]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装NodeJs]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%AE%89%E8%A3%85NodeJs.html</url>
    <content type="text"><![CDATA[下载Node.js去官网官网：https://nodejs.org/en/download/ 下载后 ftp上传或者命令下载压缩包1wget https://nodejs.org/dist/v8.10.0/node-v8.10.0-linux-x64.tar.xz 解压12[root@localhost home]# tar -xJf node-v8.10.0-linux-x64.tar.xz[root@localhost home]# cd /usr/local/data/node-v8.10 配置1vi /etc/profile 在最后加上：12export NODE_HOME=/usr/local/data/node-v8.10export PATH=$NODE_HOME/bin:$PATH 让环境变量生效1[root@localhost node-v8.10]# source /etc/profile 新版本都有自己npm 所以不需要再安装了 测试1234[root@localhost node-v8.10]# node -vv8.10.0[root@localhost node-v8.10]# npm -v5.6.0]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
</search>
