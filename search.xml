<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>全文搜索引擎 ElasticSearch</title>
      <link href="/2019/06/10/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-ElasticSearch.html"/>
      <url>/2019/06/10/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-ElasticSearch.html</url>
      
        <content type="html"><![CDATA[<p><img style="height:75px" src="https://i.loli.net/2019/07/10/5d2595fec7ef765592.png" alt="ElasticSearch"></p><h2 id="ElasticSearch-是什么"><a href="#ElasticSearch-是什么" class="headerlink" title="ElasticSearch 是什么"></a>ElasticSearch 是什么</h2><p>ElasticSearch 是一个<span style="color: #f44336">基于 Lucene 构建的开源、分布式、RESTful 接口全文搜索引擎</span>。<br><a id="more"></a><br>ElasticSearch 还是一个分布式文档数据库，其中每个字段均是被索引的数据且可被搜索，它能够扩展至数以百计的服务器存储以及处理PB级的数据。它可以在很短的时间内在储、搜索和分析大量的数据。它通常作为具有复杂搜索场景情况下的核心发动机。</p><h2 id="ElasticSearch-的优点"><a href="#ElasticSearch-的优点" class="headerlink" title="ElasticSearch 的优点"></a>ElasticSearch 的优点</h2><ul><li><strong>横向可扩展性：</strong>只需要增加台服务器，做一点儿配置，启动一下Elasticsearch就可以并入集群。</li><li><strong>分片机制提供更好的分布性：</strong>同一个索引分成多个分片(sharding), 这点类似于HDFS的块机制;分而治之的方式可提升处理效率。</li><li><strong>高可用：</strong>提供复制( replica) 机制，一个分片可以设置多个复制，使得某台服务器在宕机的情况下，集群仍旧可以照常运行，并会把服务器宕机丢失的数据信息复制恢复到其他可用节点上。口使用简单:共需一条命令就可以下载文件，然后很快就能搭建一一个站内搜索引擎。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索引擎 </tag>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业级容器 Docker</title>
      <link href="/2019/05/28/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%B9%E5%99%A8-Docker.html"/>
      <url>/2019/05/28/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%B9%E5%99%A8-Docker.html</url>
      
        <content type="html"><![CDATA[<p><img style="height:75px" src="https://i.loli.net/2019/06/28/5d15d197811f938639.png" alt="Docker"></p><h2 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h2><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现<strong> 虚拟化</strong>。</p><a id="more"></a><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h2 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h2><p>虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。</p><p><span class="text_red">虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件对资源充分利用。</span></p><h2 id="为什么要用-Docker"><a href="#为什么要用-Docker" class="headerlink" title="为什么要用 Docker"></a>为什么要用 Docker</h2><ul><li>上手快</li><li>职责的逻辑分类</li><li>快速高效的开发生命周期</li><li>鼓励使用面向服务的架构</li></ul><h2 id="容器与虚拟机比较"><a href="#容器与虚拟机比较" class="headerlink" title="容器与虚拟机比较"></a>容器与虚拟机比较</h2><p>容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p><p>与传统的虚拟机相比，Docker 优势体现为启动速度快、占用体积小。</p><h2 id="Docker-组件"><a href="#Docker-组件" class="headerlink" title="Docker 组件"></a>Docker 组件</h2><p><strong>Docker 服务器与客户端</strong></p><ul><li>Docker 是一个客户端-服务器（C/S）架构程序。</li><li>Docker 客户端只需要向 Docker 服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。</li><li>Docker 提供了一个命令行工具 Docker 以及一整套 RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</li></ul><p><strong>Docker 镜像与容器</strong></p><p><img src="https://i.loli.net/2019/06/28/5d15de1a6d4a862021.png" alt="Docker 镜像与容器"></p><p>镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义。 </p><p><img src="https://i.loli.net/2019/06/28/5d15de1a476e139291.png" alt="Docker 镜像"></p><ul><li>从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是 Docker 内部的实现细节，并且能够 在主机（译者注：运行 Docker 的机器）的文件系统上访问到。</li><li>统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。 </li></ul><p>你可以在你的主机文件系统上找到有关这些层的文件。需要注意的是，在一个运行中的容器内部，这些层是不可见的。在我的主机上，我发现它们存在于<code>/var/lib/docker/aufs</code>目录下。 </p><p>容器（container）的定义和镜像（image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 </p><p><img src="https://i.loli.net/2019/06/28/5d15de1a5e9ae82241.png" alt="Docker 容器"></p><p>细心的读者可能会发现，容器的定义并没有提及容器是否在运行，没错，这是故意的。正是这个发现帮助我理解了很多困惑。 </p><blockquote><p>要点：容器 = 镜像 + 可读层。并且容器的定义并没有提及是否要运行容器。 </p></blockquote><p><strong>总结</strong></p><ul><li>镜像是构建 Docker 的基石。用户基于镜像来运行自己的容器。镜像也是 Docker 生命周期中的“构建”部分。</li><li>镜像是基于统一文件系统的一种层式结构，由一系列指令一步一步构建出来。</li><li>镜像当作容器的”源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。</li><li>容器（container）的定义和镜像（image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</li></ul><p><strong>Registry（注册中心）</strong></p><p>Docker 用 Registry 来保存用户构建的镜像。Registry 分为公共和私有两种。Docker 公司运营公共的 Registry 叫做 Docker Hub。用户可以在 Docker Hub 注册账号，分享并保存自己的镜像（说明：在 Docker Hub 下载镜像巨慢，可以自己构建私有的 Registry）。</p><p><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=" title="https://hub.docker.com/">https://hub.docker.com/<i class="fa fa-external-link"></i></span></p><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>Docker 官方建议在 Ubuntu 中安装，因为 Docker 是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。</p><blockquote><p>​注意：这里建议安装在CentOS7.x以上的版本。</p></blockquote><p><strong>安装</strong></p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># yum 包更新到最新</span></span><br><span class="line">sudo yum update</span><br><span class="line"><span class="meta"># 安装需要的软件包， yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置 yum 源为阿里云</span></span><br><span class="line">sudo yum-config-manager --add-repo http:<span class="comment">//mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br><span class="line"><span class="meta"># 安装 docker</span></span><br><span class="line">sudo yum install docker-ce</span><br><span class="line"><span class="meta"># 安装后查看 docker 版本</span></span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure><p><strong>设置ustc的镜像</strong></p><p>ustc 是老牌的 linux 镜像服务提供者了，还在遥远的 ubuntu 5.04 版本的时候就在用。ustc 的 docker 镜像加速器速度很快。ustc docker mirror 的优势之一就是不需要注册，是真正的公共服务。</p><p><span class="exturl" data-url="aHR0cHM6Ly9sdWcudXN0Yy5lZHUuY24vd2lraS9taXJyb3JzL2hlbHAvZG9ja2Vy" title="https://lug.ustc.edu.cn/wiki/mirrors/help/docker">https://lug.ustc.edu.cn/wiki/mirrors/help/docker<i class="fa fa-external-link"></i></span></p><p>编辑该文件：<code>vi /etc/docker/daemon.json</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Docker的启动与停止</strong></p><p><strong>systemctl </strong>命令是系统服务管理器指令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动 docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止 docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 docker 状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机启动</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 docker 概要信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 docker 帮助文档</span></span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>镜像相关命令</strong></p><p>查看镜像<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure></p><p>搜索镜像<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">search</span> 镜像名称</span><br></pre></td></tr></table></figure></p><p>拉取镜像 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull 镜像名称</span><br></pre></td></tr></table></figure><p>删除镜像 </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 按镜像ID删除镜像</span><br><span class="line">docker rmi 镜像ID</span><br><span class="line"># 删除所有镜像</span><br><span class="line">docker rmi `docker images -q`</span><br></pre></td></tr></table></figure><p><strong>容器相关命令</strong></p><p>查看正在运行的容器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker ps</span></span><br></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">docker</span> <span class="comment">ps</span> <span class="comment">–a</span></span><br></pre></td></tr></table></figure><p>查看最后一次运行的容器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> ps –l</span><br></pre></td></tr></table></figure><p>查看停止的容器</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -f <span class="attribute">status</span>=exited</span><br></pre></td></tr></table></figure><p><strong>创建与启动容器</strong></p><p>创建容器命令<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><p>停止容器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">stop</span> 容器名称（或者容器<span class="keyword">ID</span>）</span><br></pre></td></tr></table></figure><p>启动容器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">start</span> 容器名称（或者容器<span class="keyword">ID</span>）</span><br></pre></td></tr></table></figure><p>文件拷贝</p><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="meta">cp</span> 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure><p>也可以将文件从容器内拷贝出来</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="meta">cp</span> 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure><p>删除指定的容器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rm 容器名称（容器ID）</span><br></pre></td></tr></table></figure><h2 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h2><p><strong>MySQL 部署</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取 mysql 镜像</span></span><br><span class="line">docker pull centos/mysql-57-centos7</span><br><span class="line"><span class="comment"># 创建容器</span></span><br><span class="line">docker <span class="builtin-name">run</span> -di <span class="attribute">--name</span>=tensquare_mysql -p 33306:3306 -e <span class="attribute">MYSQL_ROOT_PASSWORD</span>=123456 mysql</span><br></pre></td></tr></table></figure><p>-p 代表端口映射，格式为  宿主机映射端口:容器运行端口</p><p>-e 代表添加环境变量  MYSQL_ROOT_PASSWORD  是root用户的登陆密码</p><p><strong>Tomcat 部署</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull tomcat:<span class="number">7</span>-jre7</span><br><span class="line"><span class="comment"># 创建容器  -p表示地址映射</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -di --name=mytomcat -p 9000:8080 -v /usr/<span class="built_in">local</span>/webapps:/usr/<span class="built_in">local</span>/tomcat/webapps tomcat:7-jre7</span></span><br></pre></td></tr></table></figure><p><strong>Nginx 部署</strong> </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像 </span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="comment"># 创建 Nginx 容器</span></span><br><span class="line">docker <span class="builtin-name">run</span> -di <span class="attribute">--name</span>=mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><p><strong>Redis 部署</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像 </span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="comment"># 创建容器</span></span><br><span class="line">docker <span class="builtin-name">run</span> -di <span class="attribute">--name</span>=myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure><h2 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h2><p>镜像备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器保存为镜像</span></span><br><span class="line">docker commit mynginx mynginx_i</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 镜像备份</span></span><br><span class="line">docker  save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure><p>首先我们先删除掉 mynginx_img 镜像，然后执行此命令进行恢复</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 镜像恢复与迁移</span></span><br><span class="line">docker <span class="keyword">load</span> -i mynginx.tar</span><br></pre></td></tr></table></figure><p>-i 输入的文件</p><p>执行后再次查看镜像，可以看到镜像已经恢复</p><blockquote><p>更多教程可以参考官方文档，大家可以去<span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS8=" title="https://www.docker.com/">Docker 官方地址<i class="fa fa-external-link"></i></span></p></blockquote><p><span style="color: #f44336">持续更新中…</span><br><img src="/images/Come on/Come on9.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> Docker </tag>
            
            <tag> 企业级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 开发经验 02</title>
      <link href="/2019/04/26/JavaWeb-%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-02.html"/>
      <url>/2019/04/26/JavaWeb-%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-02.html</url>
      
        <content type="html"><![CDATA[<p><img style="height:75px" src="https://i.loli.net/2019/06/24/5d10392ae815c23251.png" alt="Java"></p><h2 id="java-对象转成-JSON-字符串，出现-ref"><a href="#java-对象转成-JSON-字符串，出现-ref" class="headerlink" title="java 对象转成 JSON 字符串，出现  $ref"></a>java 对象转成 JSON 字符串，出现  $ref</h2><p>原因：List 里含有重复对象<br>使用：DisableCircularReferenceDetect 来禁止循环引用检测</p><a id="more"></a><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">JSON</span><span class="selector-class">.toJSONString</span>(<span class="selector-tag">list</span>, <span class="selector-tag">SerializerFeature</span><span class="selector-class">.DisableCircularReferenceDetect</span>)</span><br></pre></td></tr></table></figure><blockquote><p>引用是通过<code>$ref</code>来表示的</p></blockquote><table><thead><tr><th>引用</th><th>描述</th></tr></thead><tbody><tr><td>“$ref”:”..”</td><td>上一级</td></tr><tr><td>“$ref”:”@”</td><td>当前对象，也就是自引用</td></tr><tr><td>“$ref”:”$”</td><td>根对象</td></tr><tr><td>“$ref”:”$.children.0”</td><td>基于路径的引用，相当于 root.getChildren().get(0)</td></tr></tbody></table><h2 id="freemarker-判断对象是否为空"><a href="#freemarker-判断对象是否为空" class="headerlink" title="freemarker 判断对象是否为空"></a>freemarker 判断对象是否为空</h2><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#<span class="meta-keyword">if</span> name??&gt;</span></span><br><span class="line">$&#123;<span class="built_in">name</span> &#125;</span><br><span class="line">&lt;/<span class="meta">#<span class="meta-keyword">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">$&#123;<span class="built_in">name</span>!<span class="string">''</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="button-标签（问题：回车会提交的）"><a href="#button-标签（问题：回车会提交的）" class="headerlink" title="button 标签（问题：回车会提交的）"></a>button 标签（问题：回车会提交的）</h2><p>submit  该按钮是提交按钮（除了 Internet Explorer，该值是其他浏览器的默认值）</p><h2 id="校验手机格式"><a href="#校验手机格式" class="headerlink" title="校验手机格式"></a>校验手机格式</h2><p>由于运营商号段随时会变，故采取非严谨的规则。</p><ul><li>Java 版本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验手机号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPhoneNumber</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line">    String regex = <span class="string">"^[1]([3-9])[0-9]&#123;9&#125;$"</span>;</span><br><span class="line">    Pattern pattern = Pattern.compile(regex);</span><br><span class="line">    <span class="keyword">return</span> pattern.matcher(number).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JS 版本</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> telStr = <span class="string">"/^[1]([3-9])[0-9]&#123;9&#125;$/"</span>;</span><br><span class="line"><span class="keyword">if</span> (!(telStr.test(number))) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"手机号格式不合法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS-怎么引用字体包"><a href="#CSS-怎么引用字体包" class="headerlink" title="CSS 怎么引用字体包"></a>CSS 怎么引用字体包</h2><p>加入一下代码，css 直接引用字体名称即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'MyNewFont'</span>;   <span class="comment">/*字体名称*/</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'font.ttf'</span>);       <span class="comment">/*字体源文件*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决引入外网资源-403-forbidden-问题"><a href="#解决引入外网资源-403-forbidden-问题" class="headerlink" title="解决引入外网资源 403 forbidden 问题"></a>解决引入外网资源 403 forbidden 问题</h2><p>页面中引入外网的链接资源，会产生一个新的 Http 清求。为了安全（URL 里可能包含用户信息），浏览器一般都会在请求头加上 referrer 字段表示来源的。</p><p>所以，此时我们要隐藏外部链接中的 referrer，在 head 标签中加入 meta，代码如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attribute">name</span>=<span class="string">"referrer"</span> <span class="attribute">content</span>=<span class="string">"no-referrer"</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="Float-和-Double-的精度缺失问题"><a href="#Float-和-Double-的精度缺失问题" class="headerlink" title="Float 和 Double 的精度缺失问题"></a>Float 和 Double 的精度缺失问题</h2><p>Float 和 Double 数据进行运算会出现精度丢失问题。解决方法：</p><ul><li>避免小数的使用</li><li>使用 BigDecimal 的 String 构造函数</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dis = <span class="number">6</span>*<span class="number">0.1</span>D;</span><br><span class="line">System.out.<span class="built_in">println</span>(dis); <span class="comment">// 0.6000000000000001</span></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">double</span> dis2 = <span class="number">6</span>/<span class="number">10</span>D;</span><br><span class="line">System.out.<span class="built_in">println</span>(dis2); <span class="comment">// 0.6</span></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(<span class="string">"6"</span>);</span><br><span class="line">BigDecimal bigDecimal2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.1"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(bigDecimal.multiply(bigDecimal2)); <span class="comment">// 0.6</span></span><br></pre></td></tr></table></figure><h2 id="IDEA-删除文件"><a href="#IDEA-删除文件" class="headerlink" title="IDEA 删除文件"></a>IDEA 删除文件</h2><p>问题描述</p><p>删除一个为指定类型的文件（默认文本 text），再次新建相同的文件时则会默认到之前的文件类型。</p><p>彻底删除方法</p><ul><li>打开 Setting</li><li>找到 File Type</li><li>找到 Recognized File Types 框中的 Text</li><li>下拉 Registered Patterns 框到最后，就找到之前新建的文件</li><li>删除即可</li></ul><p><img src="https://i.loli.net/2019/07/03/5d1c2b371e4dd35722.png" alt="彻底删除方法"></p><p><span style="color:#CA0C16">持续更新中…</span><br><img src="/images/Come on/Come on8.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 开发经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> 开发经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 开发经验 01</title>
      <link href="/2019/04/20/JavaWeb-%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-01.html"/>
      <url>/2019/04/20/JavaWeb-%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-01.html</url>
      
        <content type="html"><![CDATA[<p><img style="height:75px" src="https://i.loli.net/2019/06/24/5d10392ae815c23251.png" alt="Java"></p><h2 id="Set-无序不重复可用于比较对象"><a href="#Set-无序不重复可用于比较对象" class="headerlink" title="Set 无序不重复可用于比较对象"></a>Set 无序不重复可用于比较对象</h2><p>Set 里的元素无放入顺序，元素不可重复。</p><a id="more"></a><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="string">"男"</span>, <span class="number">20</span>);</span><br><span class="line">Person person2 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="string">"男"</span>, <span class="number">20</span>);</span><br><span class="line">Set&lt;Person&gt; hasSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">hasSet.<span class="built_in">add</span>(person1);</span><br><span class="line">hasSet.<span class="built_in">add</span>(person2);</span><br><span class="line">System.out.<span class="built_in">println</span>(hasSet.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure><h2 id="字符串转-List-lt-Class-gt"><a href="#字符串转-List-lt-Class-gt" class="headerlink" title="字符串转 List&lt;Class&gt;"></a>字符串转 <code>List&lt;Class&gt;</code></h2><p>使用的是 <code>JSONArray.parseArray</code> 而不是 <code>JSONArray.parseObject</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Mobile&gt; mobiles = (<span class="built_in">List</span>&lt;Mobile&gt;) JSONArray.parseArray(str, Mobile.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure><h2 id="关于ajaxupload-js上传图片问题"><a href="#关于ajaxupload-js上传图片问题" class="headerlink" title="关于ajaxupload.js上传图片问题"></a>关于<code>ajaxupload.js</code>上传图片问题</h2><p>谷歌浏览器慎用有道词典，有道词典会导致body里面多一个元素<br><code>&lt;audio controls=&quot;controls&quot; style=&quot;display: none;&quot;&gt;&lt;/audio&gt;</code></p><p>大多数的上传插件，为了实现无刷新页面上传，通常都会构建一个虚拟的 iframe 和 form，比如 ajaxupload，它会把 form 的 target 属性指定为 iframe 中的 name 值，目的是指定返回的页面在哪里打开，上传一般都是返回的 json 字符串，所以这时候返回 json 字符串就会被添加到 iframe 的 body 中，再获取 iframe 中 body 的值作为上传文件的返回结果。有道词典会在返回结果中多了一行<code>&lt;audio controls=&quot;controls&quot; style=&quot;display: none;&quot;&gt;&lt;/audio&gt;</code> </p><ul><li>可以关掉插件</li><li>更换浏览器</li></ul><h2 id="Json字符串有转义字符"><a href="#Json字符串有转义字符" class="headerlink" title="Json字符串有转义字符"></a>Json字符串有转义字符</h2><p>分析：Json 多次转String会产生转义字符如<code>&quot;，\</code><br>解决方法：封装方法。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理 json 字符串多出前后双引号和转义符</span></span><br><span class="line"><span class="comment"> * @param rspStr</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> jsonRemoveEscaping(<span class="keyword">String</span> rspStr) &#123;</span><br><span class="line">    rspStr = rspStr.replace(<span class="string">"\\"</span>,<span class="string">""</span>).replace(<span class="string">"\"&#123;"</span>,<span class="string">"&#123;"</span>).replace(<span class="string">"&#125;\""</span>,<span class="string">"&#125;"</span>);</span><br><span class="line">    <span class="built_in">return</span> rspStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="携程-Apollo-配置中心本地启动"><a href="#携程-Apollo-配置中心本地启动" class="headerlink" title="携程 Apollo 配置中心本地启动"></a>携程 Apollo 配置中心本地启动</h2><blockquote><p>注意事项</p></blockquote><ul><li>一般只需要在<code>/opt/settings/server.properties</code>中配置了 env=DEV 就可以直接直接启动（因为 Client 在本地仓库的包上已经有了 meta_server 的信息）</li><li>IDE 上也可以通过指定 VM 的参数，增加系统属性变量 -D 来实现调试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Denv=DEV -Ddev_meta=http://10.20.25.119:18020</span><br></pre></td></tr></table></figure><h2 id="判断线程池执行完，再执行下一步"><a href="#判断线程池执行完，再执行下一步" class="headerlink" title="判断线程池执行完，再执行下一步"></a>判断线程池执行完，再执行下一步</h2><ul><li>isShutDown当调用shutdown()或shutdownNow()方法后返回为true。 </li><li>isTerminated当调用shutdown()方法后，并且所有提交的任务完成后返回为true;</li><li>isTerminated当调用shutdownNow()方法后，成功停止后返回为true;</li><li>如果线程池任务正常完成，都为false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; typeList = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">typeList.add(<span class="number">1</span>);  </span><br><span class="line">typeList.add(<span class="number">2</span>);  </span><br><span class="line">typeList.add(<span class="number">3</span>);</span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">int</span> type:typeList) &#123;</span><br><span class="line">        pool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pool.isTerminated()) &#123;</span><br><span class="line">    <span class="comment">// 等待所有子线程结束</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// if(pool.isTerminated())&#123;执行完后，要执行的部分（这个会往后面继续走的）&#125;</span></span><br></pre></td></tr></table></figure><h2 id="ibatis-查询日期会去掉时分秒"><a href="#ibatis-查询日期会去掉时分秒" class="headerlink" title="ibatis 查询日期会去掉时分秒"></a>ibatis 查询日期会去掉时分秒</h2><ul><li>写 sql 的时候可以用 to_char 来转换</li><li>自定义转换</li></ul><p><strong>自定义转换</strong></p><p>通过配置一个 TypeHandler，让 TypeHandler 在转换的时候把<code>java.sql.Date</code>转换成<code>java.sql.Timestamp</code>。</p><p>在 sqlMapConfig 中配一下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">javaType</span>=<span class="string">"object"</span> <span class="attr">callback</span>=<span class="string">"xxx.xxx.OracleObjectTypeHandler"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>代码<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OracleObjectTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span> <span class="title">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">TypeHandler</span> </span>&#123;</span><br><span class="line">    public <span class="type">Object</span> getResult(<span class="type">ResultSet</span> rs, <span class="type">String</span> columnName)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">SQLException</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="class"><span class="keyword">object</span> </span>= rs.getObject(columnName);</span><br><span class="line">        <span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            boolean b = <span class="class"><span class="keyword">object</span> <span class="title">instanceof</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Date</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (b)</span><br><span class="line">                <span class="class"><span class="keyword">object</span> </span>= <span class="keyword">new</span> <span class="type">Date</span>(rs.getTimestamp(columnName).getTime());</span><br><span class="line">            <span class="keyword">return</span> <span class="class"><span class="keyword">object</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public <span class="type">Object</span> getResult(<span class="type">ResultSet</span> rs, int columnIndex) <span class="keyword">throws</span> <span class="type">SQLException</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="class"><span class="keyword">object</span> </span>= rs.getObject(columnIndex);</span><br><span class="line">        <span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            boolean b = <span class="class"><span class="keyword">object</span> <span class="title">instanceof</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Date</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (b)</span><br><span class="line">                <span class="class"><span class="keyword">object</span> </span>= <span class="keyword">new</span> <span class="type">Date</span>(rs.getTimestamp(columnIndex).getTime());</span><br><span class="line">            <span class="keyword">return</span> <span class="class"><span class="keyword">object</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public <span class="type">Object</span> getResult(<span class="type">CallableStatement</span> cs, int columnIndex)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">SQLException</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="class"><span class="keyword">object</span> </span>= cs.getObject(columnIndex);</span><br><span class="line">        <span class="keyword">if</span> (cs.wasNull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            boolean b = <span class="class"><span class="keyword">object</span> <span class="title">instanceof</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Date</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (b)</span><br><span class="line">                <span class="class"><span class="keyword">object</span> </span>= <span class="keyword">new</span> <span class="type">Date</span>(cs.getTimestamp(columnIndex).getTime());</span><br><span class="line">            <span class="keyword">return</span> <span class="class"><span class="keyword">object</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public <span class="type">Object</span> valueOf(<span class="type">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setParameter(<span class="type">PreparedStatement</span> ps, int i, <span class="type">Object</span> parameter,</span><br><span class="line">            <span class="type">String</span> jdbcType) <span class="keyword">throws</span> <span class="type">SQLException</span> &#123;</span><br><span class="line">        ps.setObject(i, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="SpringMvc-表单提交时-date-类型"><a href="#SpringMvc-表单提交时-date-类型" class="headerlink" title="SpringMvc 表单提交时 date 类型"></a>SpringMvc 表单提交时 date 类型</h2><p>form表单中的数据是基本类型的，对时间类型是不支持的</p><ul><li>方法一：在对应的 Controller 中新增下面的方法（针对一个类）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* form表单提交 Date类型数据绑定 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> binder </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="meta">@InitBinder</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;    </span><br><span class="line">    SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    dateFormat.setLenient(<span class="keyword">false</span>);    </span><br><span class="line">    binder.registerCustomEditor(Date.class, <span class="keyword">new</span> CustomDateEditor(dateFormat, <span class="keyword">true</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：在实体类中添加注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DateTimeFormat</span>(pattern=<span class="string">"yyyy-MM-dd"</span>) </span><br><span class="line"><span class="keyword">private</span> Date birthday;</span><br></pre></td></tr></table></figure><blockquote><p>注：配置<code>&lt;mvc:annotation-driven/&gt;</code>，默认就启用 FormattingConversionServiceFactoryBean 了。</p></blockquote><h2 id="idea-工程上传的图片，页面显示不出来"><a href="#idea-工程上传的图片，页面显示不出来" class="headerlink" title="idea 工程上传的图片，页面显示不出来"></a>idea 工程上传的图片，页面显示不出来</h2><p>1）idea里面配置<code>static/image/upload</code>文件资源</p><p><img src="https://i.loli.net/2019/06/20/5d0b450872aa152027.png" alt="idea里面配置static/image/upload文件资源"></p><p>2）idea中tomcat发布项目的默认路径是项目所在地里的target目录里面，修改工程输出到Tomcat下</p><p><img src="https://i.loli.net/2019/06/20/5d0b4508dad9c11853.png" alt="修改工程输出到Tomcat下"></p><p><img src="/images/Come on/Come on7.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 开发经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> 开发经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式架构 - 协调服务器 Zookeeper</title>
      <link href="/2019/04/03/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1%E5%99%A8-Zookeeper.html"/>
      <url>/2019/04/03/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1%E5%99%A8-Zookeeper.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://zookeeper.apache.org/doc/current/images/zookeeper_small.gif" alt="Zookeeper"></p><h2 id="什么是-Zookeeper"><a href="#什么是-Zookeeper" class="headerlink" title="什么是 Zookeeper"></a>什么是 Zookeeper</h2><p>Zookeeper 是一个分布式开源框架，提供了协调分布式应用的基本服务，它向外部应用暴露一组通用服务——分布式同步（Distributed Synchronization）、命名服务（Naming Service）、集群维护（Group Maintenance）等，简化分布式应用协调及其管理的难度，提供高性能的分布式服务。ZooKeeper本身可以以单机模式安装运行，不过它的长处在于通过分布式 ZooKeeper 集群（一个 Leader，多个 Follower），基于一定的策略来保证 ZooKeeper 集群的稳定性和可用性，从而实现分布式应用的可靠性。<br><a id="more"></a></p><ul><li>Zookeeper 是为别的分布式程序服务的</li><li>Zookeeper 本身就是一个分布式程序（只要有半数以上节点存活，zk 就能正常服务）</li><li>Zookeeper 所提供的服务涵盖：主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统&gt; 一名称服务等</li><li>虽然说可以提供各种服务，但是 zookeeper 在底层其实只提供了两个功能：管理(存储，读取)用户程序提交的数据（类似 namenode 中存放的 metadata）； 并为用户程序提供数据节点监听服务；</li></ul><h2 id="Zookeeper-集群机制"><a href="#Zookeeper-集群机制" class="headerlink" title="Zookeeper 集群机制"></a>Zookeeper 集群机制</h2><p>Zookeeper 集群的角色： Leader 和 follower </p><p>只要集群中有半数以上节点存活，集群就能提供服务</p><h2 id="Zookeeper-特性"><a href="#Zookeeper-特性" class="headerlink" title="Zookeeper 特性"></a>Zookeeper 特性</h2><ul><li>Zookeeper：一个 leader，多个 follower 组成的集群</li><li>全局数据一致：每个 server 保存一份相同的数据副本，client 无论连接到哪个 server，数据都是一致的</li><li>分布式读写，更新请求转发，由 leader 实施</li><li>更新请求顺序进行，来自同一个 client 的更新请求按其发送顺序依次执行</li><li>数据更新原子性，一次数据更新要么成功，要么失败</li><li>实时性，在一定时间范围内，client 能读到最新数据</li></ul><h2 id="Zookeeper-数据结构"><a href="#Zookeeper-数据结构" class="headerlink" title="Zookeeper 数据结构"></a>Zookeeper 数据结构</h2><p>ZooKeeper 提供的名称空间非常类似于标准文件系统。名称是由斜线（/）分隔的一系列路径元素。ZooKeeper 名称空间中的每个节点都由一个路径标识。</p><p><img src="https://i.loli.net/2019/06/20/5d0b564d4e9c551110.png" alt="Zookeeper 数据结构"></p><p>树是由节点所组成，zookeeper 的数据存储也同样是基于节点，这个节点叫做 Znode.但是，不同于树的节点，Znode 的引用方式是路径引用，类似于文件路径：<code>/app1/p_1</code>。</p><p>这样的层级结构，让每一个Znode节点拥有唯一的路径，就像命名空间一样对不同信息作出清晰的隔离。</p><h2 id="ZooKeeper-中节点和临时节点"><a href="#ZooKeeper-中节点和临时节点" class="headerlink" title="ZooKeeper 中节点和临时节点"></a>ZooKeeper 中节点和临时节点</h2><p>ZooKeeper 的节点是通过像树一样的结构来进行维护的，并且每一个节点通过路径来标示以及访问。除此之外，每一个节点还拥有自身的一些信息，包括：数据、数据长度、创建时间、修改时间等等。从这样一类既含有数据，又作为路径表标示的节点的特点中，可以看出，ZooKeeper 的节点既可以被看做是一个文件，又可以被看做是一个目录，它同时具有二者的特点。</p><p>具体地说，Znode 维护着数据、ACL（access control list，访问控制列表）、时间戳等交换版本号等数据结构，它通过对这些数据的管理来让缓存生效并且令协调更新。每当 Znode 中的数据更新后它所维护的版本号将增加，这非常类似于数据库中计数器时间戳的操作方式。</p><p>另外 Znode 还具有原子性操作的特点：命名空间中，每一个 Znode 的数据将被原子地读写。读操作将读取与 Znode 相关的所有数据，写操作将替换掉所有的数据。除此之外，每一个节点都有一个访问控制列表，这个访问控制列表规定了用户操作的权限。</p><p>ZooKeeper 中同样存在临时节点。这些节点与 session 同时存在，当 session 生命周期结束，这些临时节点也将被删除。临时节点在某些场合也发挥着非常重要的作用。</p><h2 id="Zookeeper-应用场景"><a href="#Zookeeper-应用场景" class="headerlink" title="Zookeeper 应用场景"></a>Zookeeper 应用场景</h2><ul><li>数据发布与订阅（配置中心）</li><li>负载均衡</li><li>命名服务（Naming Service）</li><li>分布式通知/协调</li><li>集群管理与 Master 选举</li><li>分布式锁</li><li>分布式事务</li></ul><p>更多教程可以参考官方文档，大家可以去<span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvY3VycmVudC9pbmRleC5odG1s" title="https://zookeeper.apache.org/doc/current/index.html">Apache ZooKeeper 官方文档<i class="fa fa-external-link"></i></span>。</p><p><span style="color:#CA0C16">持续更新中…</span><br><img src="/images/Come on/Come on6.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 协调服务器 </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式架构 - 微服务框架 Dubbo</title>
      <link href="/2019/03/21/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6-Dubbo.html"/>
      <url>/2019/03/21/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6-Dubbo.html</url>
      
        <content type="html"><![CDATA[<p><img style="height:40px" src="http://dubbo.apache.org/img/dubbo_colorful.png" alt="Dubbo"></p><h2 id="Dubbo-的背景"><a href="#Dubbo-的背景" class="headerlink" title="Dubbo 的背景"></a>Dubbo 的背景</h2><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。<br><a id="more"></a></p><ul><li><strong>单一应用架构：</strong>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 此时，用于简化增删改查工作量的<span style="color:#CA0C16">数据访问框架（ORM）</span>是关键。</li><li><strong>垂直应用架构：</strong>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 此时，用于加速前端页面开发的<span style="color:#CA0C16">Web框架（MVC）</span>是关键。</li><li><strong>分布式服务架构：</strong>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 此时，用于提高业务复用及整合的<span style="color:#CA0C16">分布式服务框架（RPC）</span>是关键。</li><li><strong>流动计算架构：</strong>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。<br>此时，用于提高机器利用率的<span style="color:#CA0C16">资源调度和治理中心（SOA）</span>是关键。</li></ul><h2 id="什么是-Dubbo"><a href="#什么是-Dubbo" class="headerlink" title="什么是 Dubbo"></a>什么是 Dubbo</h2><p>Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，SOA 服务治理方案。</p><p>简单的说，dubbo 就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有 dubbo 这样的分布式服务框架的需求。</p><p><span style="color:#CA0C16">并且本质上是个服务调用，说白了就是个远程服务调用的分布式框架（告别 Web Service 模式中的 wsdl,以服务者与消费者的方式在 dubbo 上注册）。</span></p><p>其核心部分包含:</p><ul><li><strong>1.远程通讯: </strong>提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li><li><strong>2.集群容错: </strong>提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li><strong>3.自动发现: </strong>基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><h2 id="Dubbo能做什么"><a href="#Dubbo能做什么" class="headerlink" title="Dubbo能做什么"></a>Dubbo能做什么</h2><p>具体能做什么：</p><ul><li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。      </li><li>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li><li>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li></ul><p>总结：Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 Spring 的 Schema 扩展进行加载。</p><h2 id="Dubbo-架构"><a href="#Dubbo-架构" class="headerlink" title="Dubbo 架构"></a>Dubbo 架构</h2><p>Dubbo 已进入 Apache 孵化器。<span class="exturl" data-url="aHR0cDovL2R1YmJvLmFwYWNoZS5vcmcvemgtY24vaW5kZXguaHRtbA==" title="http://dubbo.apache.org/zh-cn/index.html">Apache Dubbo官网地址<i class="fa fa-external-link"></i></span></p><p><img src="http://dubbo.apache.org/img/architecture.png" alt="Dubbo 架构"></p><p>节点角色说明：</p><ul><li>Provider: 暴露服务的服务提供方。</li><li>Consumer: 调用远程服务的服务消费方。</li><li>Registry: 服务注册与发现的注册中心。</li><li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li><li>Container: 服务运行容器。</li></ul><p>调用关系说明：</p><ul><li>0.服务容器负责启动，加载，运行服务提供者。</li><li>1.服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>2.服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>3.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><p>更多详细教程可参考<span class="exturl" data-url="aHR0cDovL2R1YmJvLmFwYWNoZS5vcmcvemgtY24vZG9jcy91c2VyL3F1aWNrLXN0YXJ0Lmh0bWw=" title="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html">官方文档<i class="fa fa-external-link"></i></span></p><p><span style="color:#CA0C16">持续更新中…</span><br><img src="/images/Come on/Come on5.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构 - Spring Cloud</title>
      <link href="/2018/07/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-Spring-Cloud.html"/>
      <url>/2018/07/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-Spring-Cloud.html</url>
      
        <content type="html"><![CDATA[<p><img style="height:75px" src="https://spring.io/img/homepage/icon-spring-cloud.svg" alt="Spring Cloud"></p><h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>Spring Cloud 是 Spring 旗下的项目之一，<span class="exturl" data-url="aHR0cDovL3Byb2plY3RzLnNwcmluZy5pby9zcHJpbmctY2xvdWQv" title="http://projects.spring.io/spring-cloud/">Spring Cloud 官网地址：http://projects.spring.io/spring-cloud/<i class="fa fa-external-link"></i></span></p><p>Spring 最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。<br><a id="more"></a><br>Spring Cloud 也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：<span style="color: #f44336">配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能</span>。其主要涉及的组件包括：</p><p>Spring Cloud Netflix</p><ul><li>Eureka：注册中心</li><li>Zuul：服务网关</li><li>Ribbon：负载均衡</li><li>Feign：服务调用</li><li>Hystix：熔断器</li></ul><p>Spring Cloud Config：由 git 存储库支持的集中式外部配置管理。</p><p>Spring Cloud Bus：用于将服务和服务实例与分布式消息相连接的事件总线，在集群中传播状态变化（例如配置更改事件）。</p><blockquote><p>更多教程可以参考官方文档，大家可以去<span class="exturl" data-url="aHR0cHM6Ly9zcHJpbmcuaW8vcHJvamVjdHMvc3ByaW5nLWNsb3Vk" title="https://spring.io/projects/spring-cloud">Spring Cloud 官方文档<i class="fa fa-external-link"></i></span>中学习。</p></blockquote><p><span style="color: #f44336">持续更新中…</span><br><img src="/images/Come on/Come on2.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构 - Spring Boot</title>
      <link href="/2018/06/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-Spring-Boot.html"/>
      <url>/2018/06/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-Spring-Boot.html</url>
      
        <content type="html"><![CDATA[<p><img style="height:75px" src="https://spring.io/img/homepage/icon-spring-boot.svg" alt="Spring Boot"></p><h2 id="什么是-Spring-Boot"><a href="#什么是-Spring-Boot" class="headerlink" title="什么是 Spring Boot"></a>什么是 Spring Boot</h2><p>Spring Boot 是 Spring 项目中的一个子工程，与我们所熟知的 Spring-framework 同属于 spring 的产品。</p><a id="more"></a><p>我们可以看到下面的一段介绍：</p><blockquote><p>Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible.</p></blockquote><p>翻译一下：</p><blockquote><p>用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。</p></blockquote><p>其实人们把 Spring Boot 称为搭建程序的<span style="color: #CA0C16">脚手架</span>。其最主要作用就是帮我们快速的构建庞大的 spring 项目，并且尽可能的减少一切 xml 配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。</p><h2 id="为什么要学习-Spring-Boot"><a href="#为什么要学习-Spring-Boot" class="headerlink" title="为什么要学习 Spring Boot"></a>为什么要学习 Spring Boot</h2><p>java 一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能 Python 程序员已经把功能写好了，究其原因注意是两点：</p><ul><li>复杂的配置</li></ul><p>项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。</p><ul><li>一个是混乱的依赖管理。</li></ul><p>项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。</p><p>我们可以使用 SpringBoot 创建 java 应用，并使用<code>java –jar</code>启动它，就能得到一个生产级别的 web 工程。</p><h2 id="Spring-Boot-的优点"><a href="#Spring-Boot-的优点" class="headerlink" title="Spring Boot 的优点"></a>Spring Boot 的优点</h2><p>Spring Boot 主要目标是：</p><ul><li>为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验。</li><li>开箱即用（启动器 starter-其实就是 SpringBoot 提供的一个 jar 包），但通过自己设置参数（.properties），即可快速摆脱这种方式。</li><li>提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等。</li><li>绝对没有代码生成，也无需 XML 配置。</li></ul><p>更多细节，大家可以到<span class="exturl" data-url="aHR0cDovL3Byb2plY3RzLnNwcmluZy5pby9zcHJpbmctYm9vdC8=" title="http://projects.spring.io/spring-boot/">Spring boot 官网<i class="fa fa-external-link"></i></span>查看。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>创建 maven 名为 springboot-demo 的 Spring Boot 工程。</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写启动类"><a href="#编写启动类" class="headerlink" title="编写启动类"></a>编写启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-controller"><a href="#编写-controller" class="headerlink" title="编写 controller"></a>编写 controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, spring boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多技能"><a href="#更多技能" class="headerlink" title="更多技能"></a>更多技能</h2><ul><li>Spring boot 整合 mybatis</li><li>Spring boot 整合 jpa</li><li>Spring boot 整合 redis</li><li>Spring boot 整合 MQ</li><li>Spring boot 整合 …</li></ul><blockquote><p>官方文档是最好的教程网站Spring boot 官网，大家可以到<span class="exturl" data-url="aHR0cHM6Ly9zcHJpbmcuaW8vcHJvamVjdHMvc3ByaW5nLWJvb3QvI2xlYXJu" title="https://spring.io/projects/spring-boot/#learn">Spring boot 官网<i class="fa fa-external-link"></i></span> 学习更多知识。<br>s<br><img src="/images/Come on/Come on11.gif"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统 - 内存数据库 Redis</title>
      <link href="/2018/05/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-Redis.html"/>
      <url>/2018/05/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-Redis.html</url>
      
        <content type="html"><![CDATA[<p><img style="height:75px" src="https://redis.io/images/redis-small.png" alt="Redis"></p><h2 id="什么是-NoSql"><a href="#什么是-NoSql" class="headerlink" title="什么是 NoSql"></a>什么是 NoSql</h2><p>NoSQL，即 Not-Only SQL，泛指非关系型的数据库。它是为了解决<span style="color: #f44336">高并发、高可用、高可扩展、大数据存储问题</span>而产生的数据库解决方案。<br><a id="more"></a><br>NoSQL 可以作为关系型数据库的良好补充，但是不能替代关系型数据库。</p><h2 id="NoSql-数据库分类"><a href="#NoSql-数据库分类" class="headerlink" title="NoSql 数据库分类"></a>NoSql 数据库分类</h2><p><strong>键值(Key-Value)存储数据库</strong><br>相关产品： Tokyo Cabinet/Tyrant、<span style="color: #f44336">Redis</span>、Voldemort、Berkeley DB<br>典型应用： 内容缓存，主要用于处理大量数据的高访问负载。<br>数据模型： 一系列键值对<br>优势： 快速查询<br>劣势： 存储的数据缺少结构化</p><p><strong>列存储数据库</strong><br>相关产品：Cassandra, <span style="color: #f44336">HBase</span>, Riak<br>典型应用：分布式的文件系统<br>数据模型：以列簇式存储，将同一列数据存在一起<br>优势：查找速度快，可扩展性强，更容易进行分布式扩展<br>劣势：功能相对局限</p><p><strong>文档型数据库</strong><br>相关产品：CouchDB、<span style="color: #f44336">MongoDB</span><br>典型应用：Web 应用（与 Key-Value 类似，Value 是结构化的）<br>数据模型： 一系列键值对<br>优势：数据结构要求不严格<br>劣势：查询性能不高，而且缺乏统一的查询语法</p><p><strong>图形(Graph)数据库</strong><br>相关数据库：Neo4J、InfoGrid、Infinite Graph<br>典型应用：社交网络<br>数据模型：图结构<br>优势：利用图结构相关算法。<br>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p><h2 id="Redis-是什么"><a href="#Redis-是什么" class="headerlink" title="Redis 是什么"></a>Redis 是什么</h2><p>Redis 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止 Redis 支持的键值数据类型如下：</p><ul><li>字符串类型</li><li>散列类型</li><li>列表类型</li><li>集合类型</li><li>有序集合类型</li></ul><h2 id="Redis-的应用场景"><a href="#Redis-的应用场景" class="headerlink" title="Redis 的应用场景"></a>Redis 的应用场景</h2><ul><li><span style="color: #f44336">缓存（数据查询、短连接、新闻内容、商品内容等等）。</span></li><li>分布式集群架构中的 session 分离。</li><li>聊天室的在线好友列表。</li><li>任务队列。（秒杀、抢购、12306 等等）</li><li>应用排行榜。</li><li>网站访问统计。</li><li>数据过期处理（可以精确到毫秒）</li></ul><p><span style="color: #f44336">持续更新中…</span></p><p><img src="/images/Come on/Come on4.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 系统 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式架构 - Nginx</title>
      <link href="/2018/04/15/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-Nginx.html"/>
      <url>/2018/04/15/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-Nginx.html</url>
      
        <content type="html"><![CDATA[<p><img style="height:75px" src="http://nginx.org/nginx.png" alt="Nginx"></p><h2 id="什么是-Nginx"><a href="#什么是-Nginx" class="headerlink" title="什么是 Nginx"></a>什么是 Nginx</h2><p>Nginx 是俄罗斯人编写的一款<span style="color: #f44336">高性能的 HTTP 和反向代理服务器</span>。</p><p>在高连接并发的情况下，它能够支持高达 <span style="color: #f44336">50000 个并发</span>连接数的响应，但是内存、CPU 等系统资源消耗却很低，运行很稳定。</p><a id="more"></a><h2 id="Nginx-的优势"><a href="#Nginx-的优势" class="headerlink" title="Nginx 的优势"></a>Nginx 的优势</h2><p>选择 Nginx 的理由也很简单：</p><ul><li>第一，它可以支持5W高并发连接；</li><li>第二，内存消耗少；</li><li>第三，成本低，如果采用 F5、NetScaler 等硬件负载均衡设备的话，需要大几十万。而 Nginx 是开源的，可以免费使用并且能用于商业用途。</li></ul><h2 id="分布式架构中的作用"><a href="#分布式架构中的作用" class="headerlink" title="分布式架构中的作用"></a>分布式架构中的作用</h2><p>最常用的有三项：</p><ul><li><strong>路由功能</strong>（与微服务对应）：域名/路径，进行路由选择后台服务器；</li><li><strong>负载功能</strong>（与高并发高可用对应）：对后台服务器集群进行负载；</li><li><strong>静态服务器</strong>（比 Tomcat 性能高很多）：在 mvvm 模式中，充当文件读取职责。</li></ul><blockquote><p>总结：实际使用中，这三项功用，会混合使用。比如先分离动静，再路由服务，再负载机器。</p></blockquote><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p><strong>正向代理</strong>：客户端自己请求出现困难。客户请了一个代理，来代自己做事，就叫代理。比如代理律师，代购，政府机关办事的代理人等等。<br><strong>反向代理</strong>：服务端推出的一个代理招牌。</p><h2 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h2><h3 id="源码编译方式"><a href="#源码编译方式" class="headerlink" title="源码编译方式"></a>源码编译方式</h3><p>一般系统中已经装了了 make 和 g++，无须再装。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 make</span></span><br><span class="line">yum -y install autoconf automake make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 g++</span></span><br><span class="line">yum -y install gcc gcc-c++</span><br></pre></td></tr></table></figure></p><p>安装nginx依赖的库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 pcre </span></span><br><span class="line">yum -y install pcre pcre-devel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 zlib </span></span><br><span class="line">yum -y install zlib zlib-devel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 openssl </span></span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure></p><p><span class="exturl" data-url="aHR0cDovL25naW54Lm9yZy9lbi9kb3dubG9hZC5odG1s" title="http://nginx.org/en/download.html">Nginx 官方下载地址<i class="fa fa-external-link"></i></span></p><p>安装 Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 下载 Nginx</span><br><span class="line">wget  http://nginx.org/download/nginx-1.16.0.tar.gz</span><br><span class="line"># 解压 Nginx</span><br><span class="line">tar -zxvf nginx-1.16.0.tar.gz</span><br><span class="line">cd nginx-1.16.0</span><br><span class="line"># 安装 HTTPS 模块</span><br><span class="line">./configure   --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</span><br><span class="line"># 安装</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><code>--prefix</code> 指定安装目录<br><code>--with-http_ssl_module</code> 安装 HTTPS 模块<br><code>make</code> 编译<br><code>make install</code> 安装</p><h3 id="yum-方式"><a href="#yum-方式" class="headerlink" title="yum 方式"></a>yum 方式</h3><p>Linux 系统下：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum扩展源</span></span><br><span class="line">yum <span class="keyword">install</span> epel-release -y</span><br><span class="line">yum <span class="keyword">install</span> nginx -y</span><br></pre></td></tr></table></figure></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li>Conf：配置文件</li><li>Html：网页文件</li><li>Logs：日志文件</li><li>Sbin：二进制程序</li></ul><h3 id="启停命令"><a href="#启停命令" class="headerlink" title="启停命令"></a>启停命令</h3><p><code>./nginx -c nginx.conf</code>的文件。如果不指定，默认为 NGINX_HOME/conf/nginx.conf<br><code>./nginx -s stop</code>  停止<br><code>./nginx -s quit</code> 退出<br><code>./nginx -s reload</code> 重新加载 nginx.conf</p><h3 id="发送信号的方式"><a href="#发送信号的方式" class="headerlink" title="发送信号的方式"></a>发送信号的方式</h3><p><code>kill -QUIT 进程号</code> 安全停止<br><code>kill -TERM 进程号</code> 立即停止</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="Nginx-全局属性的配置"><a href="#Nginx-全局属性的配置" class="headerlink" title="Nginx 全局属性的配置"></a>Nginx 全局属性的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>user</strong>：主模块命令， 指定Nginx的worker进程运行用户以及用户组，默认由 nobody 账号运行。<br><strong>worker_processes</strong>: 指定 Nginx 要开启的进程数。<br><strong>error_log</strong>：用来定义全局错设日志文件的路径和日志名称。<br>日志输出级别有 debug，info，notice，warn，error，crit 可供选择，其中 debug 输出日志最为详细，而 crit（严重）输出日志最少。默认是 error。</p><p><strong>pid</strong>: 用来指定进程 id 的存储文件位置。<br><strong>event</strong>：设定 nginx 的工作模式及连接数上限，其中参数 use 用来指定 nginx 的工作模式（这里是 epoll，epoll 是<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tL3M/aWU9VVRGLTgmYW1wO3dkPSVFNSVBNCU5QSVFOCVCNyVBRiVFNSVBNCU4RCVFNyU5NCVBOCUyMElP" title="https://www.baidu.com/s?ie=UTF-8&amp;wd=%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20IO">多路复用 IO(I/O Multiplexing)<i class="fa fa-external-link"></i></span>中的一种方式）,<br>nginx 支持的工作模式有 select ,poll,kqueue,epoll,rtsig,/dev/poll。<br>其中 select 和 poll 都是标准的工作模式，kqueue 和 epoll 是高效的工作模式，对于 linux 系统，epoll 是首选。</p><p><strong>worker_connection</strong>：是设置 nginx 每个进程最大的连接数，默认是1024，所以nginx最大的连接数 max_client=worker_processes * worker_connections。<br>进程最大连接数受到系统最大打开文件数的限制，需要设置 ulimit。</p><h3 id="http-服务器相关属性的配置"><a href="#http-服务器相关属性的配置" class="headerlink" title="http 服务器相关属性的配置"></a>http 服务器相关属性的配置</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    <span class="keyword">include</span>       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  '<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] <span class="string">"$request"</span> '</span><br><span class="line">    #                  '<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> <span class="string">"$http_referer"</span> '</span><br><span class="line">    #                  '<span class="string">"$http_user_agent"</span> <span class="string">"$http_x_forwarded_for"</span>';</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.<span class="keyword">log</span>  main;</span><br><span class="line"></span><br><span class="line">    sendfile        <span class="keyword">on</span>;</span><br><span class="line">    #tcp_nopush     <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  <span class="keyword">on</span>;</span><br></pre></td></tr></table></figure><p><strong>include</strong>：主模块命令，对配置文件所包含文件的设定，减少主配置文件的复杂度，相当于把部分设置放在别的地方，然后在包含进来，保持主配置文件的简洁。<br><strong>default_type</strong>：默认文件类型，当文件类型未定义时候就使用这类设置的。<br><strong>log_format</strong>：设定日志格式。<br><strong>sendfile</strong>：开启高效文件传输模式（zero copy 方式），避免内核缓冲区数据和用户缓冲区数据之间的拷贝。<br><strong>tcp_nopush</strong>：开启 TCP_NOPUSH 套接字（sendfile 开启时有用）<br><strong>keepalive_timeout</strong>：客户端连接超时时间<br><strong>gzip</strong>：设置是否开启 gzip 模块</p><h3 id="server-段虚拟主机的配置"><a href="#server-段虚拟主机的配置" class="headerlink" title="server 段虚拟主机的配置"></a>server 段虚拟主机的配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx's one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>listen</strong>：虚拟主机的服务端口<br><strong>server_name</strong>：用来指定ip或者域名，多个域名用逗号分开<br><strong>charset</strong>：设置字符编码<br><strong>location /</strong>：默认请求<br>    <strong>root</strong>：虚拟主机的网页根目录<br>    <strong>index</strong>：默认访问首页文件<br><strong>error_page</strong>：定义错误提示页面<br><strong>location ~ .php$</strong>：PHP 脚本请求全部转发到 FastCGI 处理.，使用FastCGI默认配置。<br><strong>location ~ /.ht</strong>：禁止访问 .htxxx 文件</p><h2 id="Nginx-日志描述"><a href="#Nginx-日志描述" class="headerlink" title="Nginx 日志描述"></a>Nginx 日志描述</h2><p>通过访问日志，你可以得到用户地域来源、跳转来源、使用终端、某个URL访问量等相关信息；<br>通过错误日志，你可以得到系统某个服务或server的性能瓶颈等。</p><p>因此，将日志好好利用，你可以得到很多有价值的信息。 </p><p>日志格式<br>打开nginx.conf配置文件：<code>vi /usr/local/nginx/conf/nginx.conf</code><br>日志部分内容：<code>#access_log  logs/access.log  main;</code></p><p>日志生成的到 Nginx 根目录 logs/access.log 文件，默认使用 <code>main</code> 日志格式，也可以自定义格式。</p><p align="center" style="font-weight: bold;">参数明细表</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>$remote_addr</td><td>客户端的ip地址(代理服务器，显示代理服务ip)</td></tr><tr><td>$remote_user</td><td>用于记录远程客户端的用户名称（一般为“-”）</td></tr><tr><td>$time_local</td><td>用于记录访问时间和时区</td></tr><tr><td>$request</td><td>用于记录请求的url以及请求方法</td></tr><tr><td>$status</td><td>响应状态码，例如：200成功、404页面找不到等。</td></tr><tr><td>$body_bytes_sent</td><td>给客户端发送的文件主体内容字节数</td></tr><tr><td>$http_user_agent</td><td>用户所使用的代理（一般为浏览器）</td></tr><tr><td>$http_x_forwarded_for</td><td>可以记录客户端IP，通过代理服务器来记录客户端的ip地址</td></tr><tr><td>$http_referer</td><td>可以记录用户是从哪个链接访问过来的</td></tr></tbody></table><p>查看日志命令 <code>tail -f /usr/local/nginx/logs/access.log</code><br><span style="color: #f44336">持续更新中…</span></p><p><img src="/images/Come on/Come on3.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 架构 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
